from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import AwaitValue from \"./AwaitValue.js\";\nexport default function AsyncGenerator(gen) {\n  var front, back;\n\n  function send(key, arg) {\n    return new Promise(function (resolve, reject) {\n      var request = {\n        key: key,\n        arg: arg,\n        resolve: resolve,\n        reject: reject,\n        next: null\n      };\n\n      if (back) {\n        back = back.next = request;\n      } else {\n        front = back = request;\n        resume(key, arg);\n      }\n    });\n  }\n\n  function resume(key, arg) {\n    try {\n      var result = gen[key](arg);\n      var value = result.value;\n      var wrappedAwait = value instanceof AwaitValue;\n      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {\n        if (wrappedAwait) {\n          resume(key === \"return\" ? \"return\" : \"next\", arg);\n          return;\n        }\n\n        settle(result.done ? \"return\" : \"normal\", arg);\n      }, function (err) {\n        resume(\"throw\", err);\n      });\n    } catch (err) {\n      settle(\"throw\", err);\n    }\n  }\n\n  function settle(type, value) {\n    switch (type) {\n      case \"return\":\n        front.resolve({\n          value: value,\n          done: true\n        });\n        break;\n\n      case \"throw\":\n        front.reject(value);\n        break;\n\n      default:\n        front.resolve({\n          value: value,\n          done: false\n        });\n        break;\n    }\n\n    front = front.next;\n\n    if (front) {\n      resume(front.key, front.arg);\n    } else {\n      back = null;\n    }\n  }\n\n  this._invoke = send;\n\n  if (typeof gen[\"return\"] !== \"function\") {\n    this[\"return\"] = undefined;\n  }\n}\n\nAsyncGenerator.prototype[typeof Symbol === \"function\" && Symbol.asyncIterator || \"@@asyncIterator\"] = function () {\n  return this;\n};\n\nAsyncGenerator.prototype.next = function (arg) {\n  return this._invoke(\"next\", arg);\n};\n\nAsyncGenerator.prototype[\"throw\"] = function (arg) {\n  return this._invoke(\"throw\", arg);\n};\n\nAsyncGenerator.prototype[\"return\"] = function (arg) {\n  return this._invoke(\"return\", arg);\n};","import AsyncGenerator from \"./AsyncGenerator.js\";\nexport default function _wrapAsyncGenerator(fn) {\n  return function () {\n    return new AsyncGenerator(fn.apply(this, arguments));\n  };\n}","export function concat(arrays, length) {\n  if (!length) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0);\n  }\n  const output = new Uint8Array(length);\n  let offset = 0;\n  for (const arr of arrays) {\n    output.set(arr, offset);\n    offset += arr.length;\n  }\n  return output;\n}","export function equals(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}","import bases from './util/bases.js';\nexport function fromString(string, encoding = 'utf8') {\n  const base = bases[encoding];\n  if (!base) {\n    throw new Error(`Unsupported encoding \"${ encoding }\"`);\n  }\n  return base.decoder.decode(`${ base.prefix }${ string }`);\n}","import bases from './util/bases.js';\nexport function toString(array, encoding = 'utf8') {\n  const base = bases[encoding];\n  if (!base) {\n    throw new Error(`Unsupported encoding \"${ encoding }\"`);\n  }\n  return base.encoder.encode(array).substring(1);\n}","import { bases } from 'multiformats/basics';\nfunction createCodec(name, prefix, encode, decode) {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: { decode }\n  };\n}\nconst string = createCodec('utf8', 'u', buf => {\n  const decoder = new TextDecoder('utf8');\n  return 'u' + decoder.decode(buf);\n}, str => {\n  const encoder = new TextEncoder();\n  return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', buf => {\n  let string = 'a';\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i]);\n  }\n  return string;\n}, str => {\n  str = str.substring(1);\n  const buf = new Uint8Array(str.length);\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n});\nconst BASES = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii: ascii,\n  binary: ascii,\n  ...bases\n};\nexport default BASES;","export function concat(arrays, length) {\n  if (!length) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0);\n  }\n  const output = new Uint8Array(length);\n  let offset = 0;\n  for (const arr of arrays) {\n    output.set(arr, offset);\n    offset += arr.length;\n  }\n  return output;\n}","import bases from './util/bases.js';\nexport function fromString(string, encoding = 'utf8') {\n  const base = bases[encoding];\n  if (!base) {\n    throw new Error(`Unsupported encoding \"${ encoding }\"`);\n  }\n  return base.decoder.decode(`${ base.prefix }${ string }`);\n}","import bases from './util/bases.js';\nexport function toString(array, encoding = 'utf8') {\n  const base = bases[encoding];\n  if (!base) {\n    throw new Error(`Unsupported encoding \"${ encoding }\"`);\n  }\n  return base.encoder.encode(array).substring(1);\n}","import { bases } from 'multiformats/basics';\nfunction createCodec(name, prefix, encode, decode) {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: { decode }\n  };\n}\nconst string = createCodec('utf8', 'u', buf => {\n  const decoder = new TextDecoder('utf8');\n  return 'u' + decoder.decode(buf);\n}, str => {\n  const encoder = new TextEncoder();\n  return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', buf => {\n  let string = 'a';\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i]);\n  }\n  return string;\n}, str => {\n  str = str.substring(1);\n  const buf = new Uint8Array(str.length);\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n});\nconst BASES = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii: ascii,\n  binary: ascii,\n  ...bases\n};\nexport default BASES;","function base(ALPHABET, name) {\n  if (ALPHABET.length >= 255) {\n    throw new TypeError('Alphabet too long');\n  }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) {\n      throw new TypeError(x + ' is ambiguous');\n    }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256);\n  var iFACTOR = Math.log(256) / Math.log(BASE);\n  function encode(source) {\n    if (source instanceof Uint8Array);\n    else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) {\n      throw new TypeError('Expected Uint8Array');\n    }\n    if (source.length === 0) {\n      return '';\n    }\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n    var b58 = new Uint8Array(size);\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n        carry += 256 * b58[it1] >>> 0;\n        b58[it1] = carry % BASE >>> 0;\n        carry = carry / BASE >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      pbegin++;\n    }\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) {\n      str += ALPHABET.charAt(b58[it2]);\n    }\n    return str;\n  }\n  function decodeUnsafe(source) {\n    if (typeof source !== 'string') {\n      throw new TypeError('Expected String');\n    }\n    if (source.length === 0) {\n      return new Uint8Array();\n    }\n    var psz = 0;\n    if (source[psz] === ' ') {\n      return;\n    }\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n    var size = (source.length - psz) * FACTOR + 1 >>> 0;\n    var b256 = new Uint8Array(size);\n    while (source[psz]) {\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n      if (carry === 255) {\n        return;\n      }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {\n        carry += BASE * b256[it3] >>> 0;\n        b256[it3] = carry % 256 >>> 0;\n        carry = carry / 256 >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      psz++;\n    }\n    if (source[psz] === ' ') {\n      return;\n    }\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch;\n  }\n  function decode(string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) {\n      return buffer;\n    }\n    throw new Error(`Non-${ name } character`);\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\nexport default _brrp__multiformats_scope_baseX;","import basex from '../../vendor/base-x.js';\nimport { coerce } from '../bytes.js';\nclass Encoder {\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${ this.prefix }${ this.baseEncode(bytes) }`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}\nclass Decoder {\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseDecode = baseDecode;\n  }\n  decode(text) {\n    if (typeof text === 'string') {\n      switch (text[0]) {\n      case this.prefix: {\n          return this.baseDecode(text.slice(1));\n        }\n      default: {\n          throw Error(`Unable to decode multibase string ${ JSON.stringify(text) }, ${ this.name } decoder only supports inputs prefixed with ${ this.prefix }`);\n        }\n      }\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n}\nclass ComposedDecoder {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n  decode(input) {\n    const prefix = input[0];\n    const decoder = this.decoders[prefix];\n    if (decoder) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${ JSON.stringify(input) }, only inputs prefixed with ${ Object.keys(this.decoders) } are supported`);\n    }\n  }\n}\nexport const or = (left, right) => new ComposedDecoder({\n  ...left.decoders || { [left.prefix]: left },\n  ...right.decoders || { [right.prefix]: right }\n});\nexport class Codec {\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n}\nexport const from = ({name, prefix, encode, decode}) => new Codec(name, prefix, encode, decode);\nexport const baseX = ({prefix, name, alphabet}) => {\n  const {encode, decode} = basex(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: text => coerce(decode(text))\n  });\n};\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  const codes = {};\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n  let end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string[i]];\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${ name } character`);\n    }\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n};\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0;\n  let buffer = 0;\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n  return out;\n};\nexport const rfc4648 = ({name, prefix, bitsPerChar, alphabet}) => {\n  return from({\n    prefix,\n    name,\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar, name);\n    }\n  });\n};","import { rfc4648 } from './base.js';\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n});\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n});\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n});\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n});\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n});\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n});\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n});\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n});\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n});","import { baseX } from './base.js';\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});","import { rfc4648 } from './base.js';\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n});\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n});\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n});\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n});","import { from } from './base.js';\nimport {\n  fromString,\n  toString\n} from '../bytes.js';\nexport const identity = from({\n  prefix: '\\0',\n  name: 'identity',\n  encode: buf => toString(buf),\n  decode: str => fromString(str)\n});","import { rfc4648 } from './base.js';\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n});","import { rfc4648 } from './base.js';\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n});","import { baseX } from './base.js';\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n});","import { rfc4648 } from './base.js';\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n});\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n});","import { baseX } from './base.js';\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n});\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n});","import { from } from './hasher.js';\nconst sha = name => async data => new Uint8Array(await crypto.subtle.digest(name, data));\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 18,\n  encode: sha('SHA-256')\n});\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 19,\n  encode: sha('SHA-512')\n});","import { coerce } from '../bytes.js';\nimport * as Digest from './digest.js';\nconst code = 0;\nconst name = 'identity';\nconst encode = coerce;\nconst digest = input => Digest.create(code, encode(input));\nexport const identity = {\n  code,\n  name,\n  encode,\n  digest\n};","import { coerce } from '../bytes.js';\nexport const name = 'raw';\nexport const code = 85;\nexport const encode = node => coerce(node);\nexport const decode = data => coerce(data);","const textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nexport const name = 'json';\nexport const code = 512;\nexport const encode = node => textEncoder.encode(JSON.stringify(node));\nexport const decode = data => JSON.parse(textDecoder.decode(data));","import * as identityBase from './bases/identity.js';\nimport * as base2 from './bases/base2.js';\nimport * as base8 from './bases/base8.js';\nimport * as base10 from './bases/base10.js';\nimport * as base16 from './bases/base16.js';\nimport * as base32 from './bases/base32.js';\nimport * as base36 from './bases/base36.js';\nimport * as base58 from './bases/base58.js';\nimport * as base64 from './bases/base64.js';\nimport * as sha2 from './hashes/sha2.js';\nimport * as identity from './hashes/identity.js';\nimport * as raw from './codecs/raw.js';\nimport * as json from './codecs/json.js';\nimport {\n  CID,\n  hasher,\n  digest,\n  varint,\n  bytes\n} from './index.js';\nconst bases = {\n  ...identityBase,\n  ...base2,\n  ...base8,\n  ...base10,\n  ...base16,\n  ...base32,\n  ...base36,\n  ...base58,\n  ...base64\n};\nconst hashes = {\n  ...sha2,\n  ...identity\n};\nconst codecs = {\n  raw,\n  json\n};\nexport {\n  CID,\n  hasher,\n  digest,\n  varint,\n  bytes,\n  hashes,\n  bases,\n  codecs\n};","const empty = new Uint8Array(0);\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\nconst fromHex = hex => {\n  const hexes = hex.match(/../g);\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n};\nconst equals = (aa, bb) => {\n  if (aa === bb)\n    return true;\n  if (aa.byteLength !== bb.byteLength) {\n    return false;\n  }\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false;\n    }\n  }\n  return true;\n};\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n    return o;\n  if (o instanceof ArrayBuffer)\n    return new Uint8Array(o);\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n};\nconst isBinary = o => o instanceof ArrayBuffer || ArrayBuffer.isView(o);\nconst fromString = str => new TextEncoder().encode(str);\nconst toString = b => new TextDecoder().decode(b);\nexport {\n  equals,\n  coerce,\n  isBinary,\n  fromHex,\n  toHex,\n  fromString,\n  toString,\n  empty\n};","import * as varint from './varint.js';\nimport * as Digest from './hashes/digest.js';\nimport { base58btc } from './bases/base58.js';\nimport { base32 } from './bases/base32.js';\nimport { coerce } from './bytes.js';\nexport class CID {\n  constructor(version, code, multihash, bytes) {\n    this.code = code;\n    this.version = version;\n    this.multihash = multihash;\n    this.bytes = bytes;\n    this.byteOffset = bytes.byteOffset;\n    this.byteLength = bytes.byteLength;\n    this.asCID = this;\n    this._baseCache = new Map();\n    Object.defineProperties(this, {\n      byteOffset: hidden,\n      byteLength: hidden,\n      code: readonly,\n      version: readonly,\n      multihash: readonly,\n      bytes: readonly,\n      _baseCache: hidden,\n      asCID: hidden\n    });\n  }\n  toV0() {\n    switch (this.version) {\n    case 0: {\n        return this;\n      }\n    default: {\n        const {code, multihash} = this;\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n        }\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n        }\n        return CID.createV0(multihash);\n      }\n    }\n  }\n  toV1() {\n    switch (this.version) {\n    case 0: {\n        const {code, digest} = this.multihash;\n        const multihash = Digest.create(code, digest);\n        return CID.createV1(this.code, multihash);\n      }\n    case 1: {\n        return this;\n      }\n    default: {\n        throw Error(`Can not convert CID version ${ this.version } to version 0. This is a bug please report`);\n      }\n    }\n  }\n  equals(other) {\n    return other && this.code === other.code && this.version === other.version && Digest.equals(this.multihash, other.multihash);\n  }\n  toString(base) {\n    const {bytes, version, _baseCache} = this;\n    switch (version) {\n    case 0:\n      return toStringV0(bytes, _baseCache, base || base58btc.encoder);\n    default:\n      return toStringV1(bytes, _baseCache, base || base32.encoder);\n    }\n  }\n  toJSON() {\n    return {\n      code: this.code,\n      version: this.version,\n      hash: this.multihash.bytes\n    };\n  }\n  get [Symbol.toStringTag]() {\n    return 'CID';\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return 'CID(' + this.toString() + ')';\n  }\n  static isCID(value) {\n    deprecate(/^0\\.0/, IS_CID_DEPRECATION);\n    return !!(value && (value[cidSymbol] || value.asCID === value));\n  }\n  get toBaseEncodedString() {\n    throw new Error('Deprecated, use .toString()');\n  }\n  get codec() {\n    throw new Error('\"codec\" property is deprecated, use integer \"code\" property instead');\n  }\n  get buffer() {\n    throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead');\n  }\n  get multibaseName() {\n    throw new Error('\"multibaseName\" property is deprecated');\n  }\n  get prefix() {\n    throw new Error('\"prefix\" property is deprecated');\n  }\n  static asCID(value) {\n    if (value instanceof CID) {\n      return value;\n    } else if (value != null && value.asCID === value) {\n      const {version, code, multihash, bytes} = value;\n      return new CID(version, code, multihash, bytes || encodeCID(version, code, multihash.bytes));\n    } else if (value != null && value[cidSymbol] === true) {\n      const {version, multihash, code} = value;\n      const digest = Digest.decode(multihash);\n      return CID.create(version, code, digest);\n    } else {\n      return null;\n    }\n  }\n  static create(version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported');\n    }\n    switch (version) {\n    case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(`Version 0 CID must use dag-pb (code: ${ DAG_PB_CODE }) block encoding`);\n        } else {\n          return new CID(version, code, digest, digest.bytes);\n        }\n      }\n    case 1: {\n        const bytes = encodeCID(version, code, digest.bytes);\n        return new CID(version, code, digest, bytes);\n      }\n    default: {\n        throw new Error('Invalid version');\n      }\n    }\n  }\n  static createV0(digest) {\n    return CID.create(0, DAG_PB_CODE, digest);\n  }\n  static createV1(code, digest) {\n    return CID.create(1, code, digest);\n  }\n  static decode(bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes);\n    if (remainder.length) {\n      throw new Error('Incorrect length');\n    }\n    return cid;\n  }\n  static decodeFirst(bytes) {\n    const specs = CID.inspectBytes(bytes);\n    const prefixSize = specs.size - specs.multihashSize;\n    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length');\n    }\n    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n    const digest = new Digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n    const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);\n    return [\n      cid,\n      bytes.subarray(specs.size)\n    ];\n  }\n  static inspectBytes(initialBytes) {\n    let offset = 0;\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset));\n      offset += length;\n      return i;\n    };\n    let version = next();\n    let codec = DAG_PB_CODE;\n    if (version === 18) {\n      version = 0;\n      offset = 0;\n    } else if (version === 1) {\n      codec = next();\n    }\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${ version }`);\n    }\n    const prefixSize = offset;\n    const multihashCode = next();\n    const digestSize = next();\n    const size = offset + digestSize;\n    const multihashSize = size - prefixSize;\n    return {\n      version,\n      codec,\n      multihashCode,\n      digestSize,\n      multihashSize,\n      size\n    };\n  }\n  static parse(source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base);\n    const cid = CID.decode(bytes);\n    cid._baseCache.set(prefix, source);\n    return cid;\n  }\n}\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n  case 'Q': {\n      const decoder = base || base58btc;\n      return [\n        base58btc.prefix,\n        decoder.decode(`${ base58btc.prefix }${ source }`)\n      ];\n    }\n  case base58btc.prefix: {\n      const decoder = base || base58btc;\n      return [\n        base58btc.prefix,\n        decoder.decode(source)\n      ];\n    }\n  case base32.prefix: {\n      const decoder = base || base32;\n      return [\n        base32.prefix,\n        decoder.decode(source)\n      ];\n    }\n  default: {\n      if (base == null) {\n        throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n      }\n      return [\n        source[0],\n        base.decode(source)\n      ];\n    }\n  }\n};\nconst toStringV0 = (bytes, cache, base) => {\n  const {prefix} = base;\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${ base.name } encoding`);\n  }\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\nconst toStringV1 = (bytes, cache, base) => {\n  const {prefix} = base;\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\nconst DAG_PB_CODE = 112;\nconst SHA_256_CODE = 18;\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version);\n  const hashOffset = codeOffset + varint.encodingLength(code);\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n  varint.encodeTo(version, bytes, 0);\n  varint.encodeTo(code, bytes, codeOffset);\n  bytes.set(multihash, hashOffset);\n  return bytes;\n};\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');\nconst readonly = {\n  writable: false,\n  configurable: false,\n  enumerable: true\n};\nconst hidden = {\n  writable: false,\n  enumerable: false,\n  configurable: false\n};\nconst version = '0.0.0-dev';\nconst deprecate = (range, message) => {\n  if (range.test(version)) {\n    console.warn(message);\n  } else {\n    throw new Error(message);\n  }\n};\nconst IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.\nFollowing code pattern:\n\nif (CID.isCID(value)) {\n  doSomethingWithCID(value)\n}\n\nIs replaced with:\n\nconst cid = CID.asCID(value)\nif (cid) {\n  // Make sure to use cid instead of value\n  doSomethingWithCID(cid)\n}\n`;","import {\n  coerce,\n  equals as equalBytes\n} from '../bytes.js';\nimport * as varint from '../varint.js';\nexport const create = (code, digest) => {\n  const size = digest.byteLength;\n  const sizeOffset = varint.encodingLength(code);\n  const digestOffset = sizeOffset + varint.encodingLength(size);\n  const bytes = new Uint8Array(digestOffset + size);\n  varint.encodeTo(code, bytes, 0);\n  varint.encodeTo(size, bytes, sizeOffset);\n  bytes.set(digest, digestOffset);\n  return new Digest(code, size, digest, bytes);\n};\nexport const decode = multihash => {\n  const bytes = coerce(multihash);\n  const [code, sizeOffset] = varint.decode(bytes);\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset));\n  const digest = bytes.subarray(sizeOffset + digestOffset);\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length');\n  }\n  return new Digest(code, size, digest, bytes);\n};\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true;\n  } else {\n    return a.code === b.code && a.size === b.size && equalBytes(a.bytes, b.bytes);\n  }\n};\nexport class Digest {\n  constructor(code, size, digest, bytes) {\n    this.code = code;\n    this.size = size;\n    this.digest = digest;\n    this.bytes = bytes;\n  }\n}","import * as Digest from './digest.js';\nexport const from = ({name, code, encode}) => new Hasher(name, code, encode);\nexport class Hasher {\n  constructor(name, code, encode) {\n    this.name = name;\n    this.code = code;\n    this.encode = encode;\n  }\n  digest(input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input);\n      return result instanceof Uint8Array ? Digest.create(this.code, result) : result.then(digest => Digest.create(this.code, digest));\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}","var encode_1 = encode;\nvar MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n  while (num >= INT) {\n    out[offset++] = num & 255 | MSB;\n    num /= 128;\n  }\n  while (num & MSBALL) {\n    out[offset++] = num & 255 | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  encode.bytes = offset - oldOffset + 1;\n  return out;\n}\nvar decode = read;\nvar MSB$1 = 128, REST$1 = 127;\nfunction read(buf, offset) {\n  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint');\n    }\n    b = buf[counter++];\n    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1);\n  read.bytes = counter - offset;\n  return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (value) {\n  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;\n};\nvar varint = {\n  encode: encode_1,\n  decode: decode,\n  encodingLength: length\n};\nvar _brrp_varint = varint;\nexport default _brrp_varint;","import varint from '../vendor/varint.js';\nexport const decode = data => {\n  const code = varint.decode(data);\n  return [\n    code,\n    varint.decode.bytes\n  ];\n};\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset);\n  return target;\n};\nexport const encodingLength = int => {\n  return varint.encodingLength(int);\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","__webpack_require__.amdD = function () {\n\tthrow new Error('define cannot be used indirect');\n};","__webpack_require__.amdO = {};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","var getProto = Object.getPrototypeOf ? function(obj) { return Object.getPrototypeOf(obj); } : function(obj) { return obj.__proto__; };\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach(function(key) { def[key] = function() { return value[key]; }; });\n\t}\n\tdef['default'] = function() { return value; };\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + (chunkId === 967 ? \"ipld\" : chunkId) + \".\" + {\"46\":\"b4f26cc1\",\"94\":\"66c334ae\",\"100\":\"ce5f8c61\",\"109\":\"7c23e454\",\"370\":\"4fa8e640\",\"397\":\"d9f485e9\",\"459\":\"468b934d\",\"484\":\"553ef823\",\"486\":\"47b24607\",\"578\":\"3a23ffed\",\"583\":\"b59d23b5\",\"647\":\"7e0dab0c\",\"680\":\"06c0a804\",\"727\":\"a54159c8\",\"760\":\"e0e3c173\",\"841\":\"d99d8bfa\",\"878\":\"234dd5d4\",\"898\":\"22acf054\",\"941\":\"596a6164\",\"967\":\"602ac4fe\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/css/\" + chunkId + \".\" + {\"109\":\"d8f942f1\",\"486\":\"6601961d\",\"578\":\"367f0ba9\",\"647\":\"3c1607f0\"}[chunkId] + \".chunk.css\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.hmd = function(module) {\n\tmodule = Object.create(module);\n\tif (!module.children) module.children = [];\n\tObject.defineProperty(module, 'exports', {\n\t\tenumerable: true,\n\t\tset: function() {\n\t\t\tthrow new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);\n\t\t}\n\t});\n\treturn module;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","var inProgress = {};\nvar dataWebpackPrefix = \"ipfs-webui:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = function(url, done, key, chunkId) {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = function(prev, event) {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach(function(fn) { return fn(event); });\n\t\tif(prev) return prev(event);\n\t}\n\t;\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"./\";","var createStylesheet = function(chunkId, fullhref, resolve, reject) {\n\tvar linkTag = document.createElement(\"link\");\n\n\tlinkTag.rel = \"stylesheet\";\n\tlinkTag.type = \"text/css\";\n\tvar onLinkComplete = function(event) {\n\t\t// avoid mem leaks.\n\t\tlinkTag.onerror = linkTag.onload = null;\n\t\tif (event.type === 'load') {\n\t\t\tresolve();\n\t\t} else {\n\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\tvar realHref = event && event.target && event.target.href || fullhref;\n\t\t\tvar err = new Error(\"Loading CSS chunk \" + chunkId + \" failed.\\n(\" + realHref + \")\");\n\t\t\terr.code = \"CSS_CHUNK_LOAD_FAILED\";\n\t\t\terr.type = errorType;\n\t\t\terr.request = realHref;\n\t\t\tlinkTag.parentNode.removeChild(linkTag)\n\t\t\treject(err);\n\t\t}\n\t}\n\tlinkTag.onerror = linkTag.onload = onLinkComplete;\n\tlinkTag.href = fullhref;\n\n\tdocument.head.appendChild(linkTag);\n\treturn linkTag;\n};\nvar findStylesheet = function(href, fullhref) {\n\tvar existingLinkTags = document.getElementsByTagName(\"link\");\n\tfor(var i = 0; i < existingLinkTags.length; i++) {\n\t\tvar tag = existingLinkTags[i];\n\t\tvar dataHref = tag.getAttribute(\"data-href\") || tag.getAttribute(\"href\");\n\t\tif(tag.rel === \"stylesheet\" && (dataHref === href || dataHref === fullhref)) return tag;\n\t}\n\tvar existingStyleTags = document.getElementsByTagName(\"style\");\n\tfor(var i = 0; i < existingStyleTags.length; i++) {\n\t\tvar tag = existingStyleTags[i];\n\t\tvar dataHref = tag.getAttribute(\"data-href\");\n\t\tif(dataHref === href || dataHref === fullhref) return tag;\n\t}\n};\nvar loadStylesheet = function(chunkId) {\n\treturn new Promise(function(resolve, reject) {\n\t\tvar href = __webpack_require__.miniCssF(chunkId);\n\t\tvar fullhref = __webpack_require__.p + href;\n\t\tif(findStylesheet(href, fullhref)) return resolve();\n\t\tcreateStylesheet(chunkId, fullhref, resolve, reject);\n\t});\n}\n// object to store loaded CSS chunks\nvar installedCssChunks = {\n\t179: 0\n};\n\n__webpack_require__.f.miniCss = function(chunkId, promises) {\n\tvar cssChunks = {\"109\":1,\"486\":1,\"578\":1,\"647\":1};\n\tif(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);\n\telse if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {\n\t\tpromises.push(installedCssChunks[chunkId] = loadStylesheet(chunkId).then(function() {\n\t\t\tinstalledCssChunks[chunkId] = 0;\n\t\t}, function(e) {\n\t\t\tdelete installedCssChunks[chunkId];\n\t\t\tthrow e;\n\t\t}));\n\t}\n};\n\n// no hmr","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t179: 0\n};\n\n__webpack_require__.f.j = function(chunkId, promises) {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise(function(resolve, reject) { installedChunkData = installedChunks[chunkId] = [resolve, reject]; });\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = function(event) {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = function(parentChunkLoadingFunction, data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkipfs_webui\"] = self[\"webpackChunkipfs_webui\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","var findAnchorTag = function (el) {\n  if (!el) { return null; }\n  return el.tagName === 'A' ? el : findAnchorTag(el.parentElement);\n};\n\nvar getLocalPathname = function (a) { return a.href.indexOf(location.protocol + '//' + location.host) !== -1 ? a.href.split(location.host, 2)[1] : null; };\n\nvar getNavHelper = function (onInternalNav) { return function (e) {\n  if (e.button === 0 && !e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey) {\n    var aTag = findAnchorTag(e.target);\n\n    if (aTag && aTag.target !== '_blank' && aTag.target !== '_external' && aTag.rel !== 'external' && !aTag.hasAttribute('download')) {\n      var url = getLocalPathname(aTag);\n\n      if (url) {\n        e.preventDefault();\n        onInternalNav(url);\n      }\n    }\n  }\n}; };\n\nexport { findAnchorTag, getNavHelper };\n","var _excluded = [\"title\", \"titleId\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport * as React from \"react\";\n\nvar _ref2 = /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M0 288.61h18.72v110.45H0zm37.44 0h38.19c8.31 0 15.25.95 20.61 2.74a31.14 31.14 0 0112.73 7.47 25 25 0 016.52 10.72 43.53 43.53 0 011.9 12.73 49.25 49.25 0 01-1.9 13.57 28.61 28.61 0 01-6.52 11.36 33.64 33.64 0 01-12.74 7.68c-5.36 1.89-12.09 2.84-20.3 2.84H55.85v41.34H37.44zm38.08 53.65a40.17 40.17 0 0011.71-1.37 17.09 17.09 0 007.15-3.89 14 14 0 003.68-6.1 29.15 29.15 0 001-8 26.14 26.14 0 00-1-8.1 13.3 13.3 0 00-3.83-5.78 18.75 18.75 0 00-7.25-3.58 42.68 42.68 0 00-11.47-1.26H56.06v38.08zm126.12-53.65v16.1h-51.75v31.24h48.7v16.2h-48.7v46.91h-18.72V288.61zm27.59 76.65c.84 7.26 3.47 12.52 7.78 15.78s10.94 4.95 19.57 4.95a33.32 33.32 0 0010.62-1.37 22.13 22.13 0 006.95-3.68 13 13 0 003.68-5.47 21.13 21.13 0 001.05-6.73 16.87 16.87 0 00-.74-5.16 13.3 13.3 0 00-2.73-4.73 19.17 19.17 0 00-5.37-3.79 40.06 40.06 0 00-8.62-2.52l-14.1-2.63a90.66 90.66 0 01-14.83-3.89 36.1 36.1 0 01-10.94-6.11 23.22 23.22 0 01-6.63-9.25 36.44 36.44 0 01-2.2-13.36 27.26 27.26 0 0111.88-23.56 36.6 36.6 0 0113.26-5.89 73.44 73.44 0 0116.62-1.9c7.57 0 14 .84 19.14 2.63a37.35 37.35 0 0112.52 6.84 30.13 30.13 0 017.26 9.78 44.4 44.4 0 013.36 11.57l-17.67 2.74c-1.47-6.21-3.89-10.73-7.47-13.78s-9.18-4.47-16.96-4.47a43.2 43.2 0 00-11.05 1.15 20.19 20.19 0 00-7.15 3.26 12.52 12.52 0 00-3.89 4.84 14.75 14.75 0 00-1.16 5.68c0 4.84 1.26 8.42 3.89 10.84s7.26 4.2 13.89 5.57l15.25 2.95c11.67 2.21 20.19 5.89 25.66 11s8.21 12.73 8.21 22.51a34 34 0 01-2.53 12.94 26.78 26.78 0 01-7.78 10.31 39.09 39.09 0 01-13 6.94 59.1 59.1 0 01-18.2 2.53c-14.1 0-25.25-3-33.24-9s-12.56-15.07-13.33-27.52z\",\n  fill: \"#fff\"\n});\n\nvar _ref3 = /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M45.95 178.65l103.14 59.55 103.14-59.55V59.55L149.09 0 45.95 59.55z\",\n  fill: \"#469ea2\"\n});\n\nvar _ref4 = /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M138.53 14.26l-74.9 43.2a21.18 21.18 0 010 4.06l74.78 43.22a17.85 17.85 0 0121.24 0l74.78-43.22a21.18 21.18 0 010-4.06l-74.66-43.2a17.85 17.85 0 01-21.24 0zm103.14 59.17l-74.9 43.71a18.08 18.08 0 01-10.54 18.41l.13 86a18.91 18.91 0 013.43 2l74.76-43.29a18.08 18.08 0 0110.56-18.42V75.39a32 32 0 01-3.44-1.96zm-185.16.49a19.2 19.2 0 01-3.44 2v86.44a17.57 17.57 0 0110.56 18.38l74.78 43.22a19.25 19.25 0 013.44-2v-86.41a17.55 17.55 0 01-10.56-18.41z\",\n  fill: \"#6acad1\"\n});\n\nvar _ref5 = /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M149.09 12.89l92.21 53.29v106.46l-92.21 53.28-92.21-53.28V66.06l92.21-53.17m0-12.64L45.95 59.8v119.1l103.14 59.55 103.14-59.55V59.8z\",\n  fill: \"#469ea2\"\n});\n\nvar _ref6 = /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M149.83 139.36h-1.48a19.27 19.27 0 01-19.27-19.1v-1.6a19.28 19.28 0 0119.15-19.33h1.6a19.28 19.28 0 0119.27 19.16v1.59a19.31 19.31 0 01-19.27 19.28zm0 79.2h-1.48a19.16 19.16 0 00-16.82 9.82l17.56 10.07 17.56-10.07a19.15 19.15 0 00-16.82-9.82zm102.52-59.55h-.73a19.28 19.28 0 00-19.28 19.15v1.6a19 19 0 002.45 9.33l17.56-10.19zM234.79 49.73a18.94 18.94 0 00-2.45 9.33v1.47a19.28 19.28 0 0019.15 19.28h.86v-20l-17.56-10.08zM149.09.26l-17.56 10.05a19.28 19.28 0 0016.82 10h1.48a19.15 19.15 0 0016.82-9.82zM63.51 49.61L45.95 59.8v20h.74a19.28 19.28 0 0019.28-19.14v-1.6a19.64 19.64 0 00-2.46-9.45zm-16.82 109.4h-.74v19.89l17.56 10.19a18.9 18.9 0 002.46-9.33v-1.5a19.31 19.31 0 00-19.28-19.27z\",\n  fill: \"#469ea2\"\n});\n\nvar _ref7 = /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M149.09 239.06V119.84L45.95 60.26v119.25z\",\n  fill: \"#083b54\",\n  fillOpacity: 0.15\n});\n\nvar _ref8 = /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M252.35 178.41V59.31l-103.12 59.55v119.22z\",\n  fill: \"#083b54\",\n  fillOpacity: 0.05\n});\n\nfunction SvgIpfsLogoTextVert(_ref, svgRef) {\n  var title = _ref.title,\n      titleId = _ref.titleId,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 298.31 401.8\",\n    ref: svgRef,\n    \"aria-labelledby\": titleId\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", {\n    id: titleId\n  }, title) : null, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8);\n}\n\nvar ForwardRef = /*#__PURE__*/React.forwardRef(SvgIpfsLogoTextVert);\nexport default __webpack_public_path__ + \"static/media/ipfs-logo-text-vert.6fc9edd5f753fba1c9f20b667e26d29d.svg\";\nexport { ForwardRef as ReactComponent };","var _excluded = [\"title\", \"titleId\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport * as React from \"react\";\n\nvar _ref2 = /*#__PURE__*/React.createElement(\"defs\", null, /*#__PURE__*/React.createElement(\"style\", null, \".cls-1{fill:#fff}.cls-2{fill:#469ea2}.cls-3{fill:#6acad1}.cls-4,.cls-5{fill:#083b54}.cls-4{fill-opacity:.15}.cls-5{fill-opacity:.05}\"));\n\nvar _ref3 = /*#__PURE__*/React.createElement(\"path\", {\n  className: \"cls-1\",\n  d: \"M239 63h17.8v105H239V63zm35.6 0h36.3c7.9 0 14.5.9 19.6 2.6s9.2 4.1 12.1 7.1a24.45 24.45 0 0 1 6.2 10.2 40.75 40.75 0 0 1 1.8 12.1 45.69 45.69 0 0 1-1.8 12.9 26.58 26.58 0 0 1-6.2 10.8 30.59 30.59 0 0 1-12.1 7.3c-5.1 1.8-11.5 2.7-19.3 2.7h-19.1V168h-17.5V63zm36.2 51a38.37 38.37 0 0 0 11.1-1.3 16.3 16.3 0 0 0 6.8-3.7 13.34 13.34 0 0 0 3.5-5.8 29.75 29.75 0 0 0 1-7.6 25.68 25.68 0 0 0-1-7.7 12 12 0 0 0-3.6-5.5 17.15 17.15 0 0 0-6.9-3.4 41.58 41.58 0 0 0-10.9-1.2h-18.5V114h18.5zm119.9-51v15.3h-49.2V108h46.3v15.4h-46.3V168h-17.8V63h67zm26.2 72.9c.8 6.9 3.3 11.9 7.4 15s10.4 4.7 18.6 4.7a32.61 32.61 0 0 0 10.1-1.3 20.52 20.52 0 0 0 6.6-3.5 12 12 0 0 0 3.5-5.2 19.08 19.08 0 0 0 1-6.4 16.14 16.14 0 0 0-.7-4.9 12.87 12.87 0 0 0-2.6-4.5 16.59 16.59 0 0 0-5.1-3.6 35 35 0 0 0-8.2-2.4l-13.4-2.5a89.76 89.76 0 0 1-14.1-3.7 33.51 33.51 0 0 1-10.4-5.8 22.28 22.28 0 0 1-6.3-8.8 34.1 34.1 0 0 1-2.1-12.7 26 26 0 0 1 11.3-22.4 36.35 36.35 0 0 1 12.6-5.6 65.89 65.89 0 0 1 15.8-1.8c7.2 0 13.3.8 18.2 2.5a34.46 34.46 0 0 1 11.9 6.5 28.21 28.21 0 0 1 6.9 9.3 42.1 42.1 0 0 1 3.2 11l-16.8 2.6c-1.4-5.9-3.7-10.2-7.1-13.1s-8.7-4.3-16.1-4.3a43.9 43.9 0 0 0-10.5 1.1 19.47 19.47 0 0 0-6.8 3.1 11.63 11.63 0 0 0-3.7 4.6 14.08 14.08 0 0 0-1.1 5.4c0 4.6 1.2 8 3.7 10.3s6.9 4 13.2 5.3l14.5 2.8c11.1 2.1 19.2 5.6 24.4 10.5s7.8 12.1 7.8 21.4a31.37 31.37 0 0 1-2.4 12.3 25.27 25.27 0 0 1-7.4 9.8 36.58 36.58 0 0 1-12.4 6.6 56 56 0 0 1-17.3 2.4c-13.4 0-24-2.8-31.6-8.5s-11.9-14.4-12.6-26.2h18z\"\n});\n\nvar _ref4 = /*#__PURE__*/React.createElement(\"path\", {\n  className: \"cls-2\",\n  d: \"M30.3 164l84 48.5 84-48.5V67l-84-48.5-84 48.5v97z\"\n});\n\nvar _ref5 = /*#__PURE__*/React.createElement(\"path\", {\n  className: \"cls-3\",\n  d: \"M105.7 30.1l-61 35.2a18.19 18.19 0 0 1 0 3.3l60.9 35.2a14.55 14.55 0 0 1 17.3 0l60.9-35.2a18.19 18.19 0 0 1 0-3.3L123 30.1a14.55 14.55 0 0 1-17.3 0zm84 48.2l-61 35.6a14.73 14.73 0 0 1-8.6 15l.1 70a15.57 15.57 0 0 1 2.8 1.6l60.9-35.2a14.73 14.73 0 0 1 8.6-15V79.9a20 20 0 0 1-2.8-1.6zm-150.8.4a15.57 15.57 0 0 1-2.8 1.6v70.4a14.38 14.38 0 0 1 8.6 15l60.9 35.2a15.57 15.57 0 0 1 2.8-1.6v-70.4a14.38 14.38 0 0 1-8.6-15L38.9 78.7z\"\n});\n\nvar _ref6 = /*#__PURE__*/React.createElement(\"path\", {\n  className: \"cls-2\",\n  d: \"M114.3 29l75.1 43.4v86.7l-75.1 43.4-75.1-43.4V72.3L114.3 29m0-10.3l-84 48.5v97l84 48.5 84-48.5v-97l-84-48.5z\"\n});\n\nvar _ref7 = /*#__PURE__*/React.createElement(\"path\", {\n  className: \"cls-2\",\n  d: \"M114.9 132h-1.2A15.66 15.66 0 0 1 98 116.3v-1.2a15.66 15.66 0 0 1 15.7-15.7h1.2a15.66 15.66 0 0 1 15.7 15.7v1.2a15.66 15.66 0 0 1-15.7 15.7zm0 64.5h-1.2a15.65 15.65 0 0 0-13.7 8l14.3 8.2 14.3-8.2a15.65 15.65 0 0 0-13.7-8zm83.5-48.5h-.6a15.66 15.66 0 0 0-15.7 15.7v1.2a15.13 15.13 0 0 0 2 7.6l14.3-8.3V148zm-14.3-89a15.4 15.4 0 0 0-2 7.6v1.2a15.66 15.66 0 0 0 15.7 15.7h.6V67.2L184.1 59zm-69.8-40.3L100 26.9a15.73 15.73 0 0 0 13.7 8.1h1.2a15.65 15.65 0 0 0 13.7-8l-14.3-8.3zM44.6 58.9l-14.3 8.3v16.3h.6a15.66 15.66 0 0 0 15.7-15.7v-1.2a16.63 16.63 0 0 0-2-7.7zM30.9 148h-.6v16.2l14.3 8.3a15.4 15.4 0 0 0 2-7.6v-1.2A15.66 15.66 0 0 0 30.9 148z\"\n});\n\nvar _ref8 = /*#__PURE__*/React.createElement(\"path\", {\n  className: \"cls-4\",\n  d: \"M114.3 213.2v-97.1l-84-48.5v97.1z\"\n});\n\nvar _ref9 = /*#__PURE__*/React.createElement(\"path\", {\n  className: \"cls-5\",\n  d: \"M198.4 163.8v-97l-84 48.5v97.1z\"\n});\n\nfunction SvgIpfsLogoTextHoriz(_ref, svgRef) {\n  var title = _ref.title,\n      titleId = _ref.titleId,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    id: \"Layer_1\",\n    \"data-name\": \"Layer 1\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 553 235.3\",\n    ref: svgRef,\n    \"aria-labelledby\": titleId\n  }, props), _ref2, title === undefined ? /*#__PURE__*/React.createElement(\"title\", {\n    id: titleId\n  }, \"IPFS logo (new)\") : title ? /*#__PURE__*/React.createElement(\"title\", {\n    id: titleId\n  }, title) : null, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9);\n}\n\nvar ForwardRef = /*#__PURE__*/React.forwardRef(SvgIpfsLogoTextHoriz);\nexport default __webpack_public_path__ + \"static/media/ipfs-logo-text-horiz.2c5486c412b66a8fad882021ae564641.svg\";\nexport { ForwardRef as ReactComponent };","import * as React from 'react'\n\nfunction SvgStrokeMarketing (props) {\n  return (\n    <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 100\" {...props}>\n      <path d=\"M76.595 19.785h-52.93a3.93 3.93 0 00-3.92 3.92v39.12a5.74 5.74 0 005.73 5.73h23.79v6.25h-9.67a4 4 0 00-4 4 3.59 3.59 0 00.08.81l.12.6h28.49l.13-.6a4.28 4.28 0 00.08-.81 4 4 0 00-4-4h-9.73v-6.25h25.83a3.67 3.67 0 003.66-3.67v-41.44a3.67 3.67 0 00-3.66-3.66zm-13.61 58.94h-25.95a2.52 2.52 0 012.56-2.42h20.88a2.51 2.51 0 012.51 2.42zm-39.32-55.94h52.93a.66.66 0 01.66.66v5.56h-54.51v-5.3a.92.92 0 01.92-.92zm52.93 42.77h-51.12a2.73 2.73 0 01-2.73-2.73v-32.29h54.53v34.35a.67.67 0 01-.68.67z\" />\n      <path d=\"M68.315 35.735a3.61 3.61 0 00-3.61 3.61 3.58 3.58 0 00.74 2.17l-9.77 10.38a3.5 3.5 0 00-4.13.46l-7.4-5a3.61 3.61 0 10-6.9-1.48 3.58 3.58 0 00.41 1.63l-.06-.05-4.54 5.55a3.57 3.57 0 00-1.35-.27 3.62 3.62 0 102.6 1.11l4.29-5.21a3.53 3.53 0 002.3.86 3.62 3.62 0 002.39-.92l7.41 5a3.52 3.52 0 00-.37 1.43 3.635 3.635 0 107.27 0 3.57 3.57 0 00-.74-2.16l9.74-10.35a3.49 3.49 0 001.73.46 3.61 3.61 0 000-7.22zm-36.61 22.72a2.11 2.11 0 112.11-2.11 2.12 2.12 0 01-2.11 2.11zm9.15-10.45a2.11 2.11 0 112.11-2.11 2.12 2.12 0 01-2.11 2.11zm13.08 9.15a2.11 2.11 0 112.11-2.15 2.11 2.11 0 01-2.11 2.14zm14.38-15.7a2.11 2.11 0 112.11-2.11 2.11 2.11 0 01-2.11 2.11z\" />\n    </svg>\n  )\n}\n\nexport default SvgStrokeMarketing\n","import * as React from 'react'\n\nfunction SvgStrokeWeb (props) {\n  return (\n    <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 100\" {...props}>\n      <path d=\"M36 33.4h14.21a1 1 0 000-2H36a1 1 0 000 2zm0 8.84h14.21a1 1 0 000-2H36a1 1 0 000 2zm30.08 7.57a1.07 1.07 0 00-.07-.19.64.64 0 010-.07l-.08-.08-.14-.15-.15-.1-.18-.08h-.2a.35.35 0 00-.11 0H36a1 1 0 00-1 1v17.68a.71.71 0 000 .2.64.64 0 00.06.18.36.36 0 010 .07.65.65 0 00.13.16 1.26 1.26 0 00.28.19h.08a1 1 0 00.34.07h29.24a1 1 0 001-1V50a1.62 1.62 0 00-.05-.19zm-4.52 1.26L37 66V51.07zm-22 15.68l24.52-14.9v14.9z\" />\n      <path d=\"M75.13 37.17v-.05L56.55 17.8H30a5.51 5.51 0 00-5.5 5.5v53.4a5.51 5.51 0 005.5 5.5h40a5.51 5.51 0 005.5-5.5V37.51zM56.91 22.51l14 14.61h-7.08c-4 0-6.92-2.53-6.92-6zM70 79.2H30a2.5 2.5 0 01-2.5-2.5V23.3a2.5 2.5 0 012.5-2.5h24.91v10.31c0 4.64 3.75 8 8.92 8h8.63V76.7A2.5 2.5 0 0170 79.2z\" />\n    </svg>\n  )\n}\n\nexport default SvgStrokeWeb\n","import * as React from 'react'\n\nfunction SvgStrokeSettings (props) {\n  return (\n    <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 100\" {...props}>\n      <path d=\"M50.077 42.884h-.09a7.14 7.14 0 00-5 2.06 7.07 7.07 0 00-2.11 5 7.16 7.16 0 007.11 7.21 7.14 7.14 0 00.09-14.27zm-.09 11.67a4.57 4.57 0 01-4.54-4.54 4.46 4.46 0 011.34-3.19 4.54 4.54 0 013.2-1.34 4.53 4.53 0 014.48 4.67 4.54 4.54 0 01-4.48 4.4z\" />\n      <path d=\"M83.697 56.764c-3.29-1.27-4.93-3.4-5-6.51-.07-3.29 1.56-5.53 5-6.86a1.3 1.3 0 00.82-1.38c-.25-2.51-3-9-4.45-10.72a1.3 1.3 0 00-1.53-.28c-3.25 1.52-6 1.15-8.27-1.14-2.27-2.29-2.71-5-1.17-8.39a1.29 1.29 0 00-.5-1.65 34.72 34.72 0 00-10.42-4.29 1.29 1.29 0 00-1.52.84c-1.11 3.22-3.1 4.9-6.1 5.12-3.57.27-6-1.41-7.36-5.11a1.31 1.31 0 00-1.53-.82 35.49 35.49 0 00-10.38 4.37 1.3 1.3 0 00-.48 1.66c1.56 3.28 1.21 6-1.07 8.32-2.28 2.32-5.05 2.74-8.38 1.21a1.31 1.31 0 00-1.66.5 35.31 35.31 0 00-4.23 10.38 1.31 1.31 0 00.82 1.51c3.34 1.23 5 3.35 5.07 6.51.07 3.16-1.55 5.53-5 6.86a1.3 1.3 0 00-.79 1.52 34.69 34.69 0 004.42 10.34 1.29 1.29 0 001.63.5c3.23-1.44 5.9-1.06 8.16 1.14s2.75 5 1.32 8.23a1.3 1.3 0 00.52 1.63 35.46 35.46 0 0010.37 4.23 1.15 1.15 0 00.26 0 1.44 1.44 0 001.23-.79 2.43 2.43 0 00.14-.28 6.89 6.89 0 0113-.17 1.7 1.7 0 002.16 1.06 35.78 35.78 0 009.44-3.9l.36-.24.11-.08a1.29 1.29 0 00.47-1.61c-1.32-3-1.06-5.51.8-7.68 2.29-2.66 5.12-3.22 8.67-1.71a1.29 1.29 0 001.61-.51 34.87 34.87 0 004.3-10.33 1.29 1.29 0 00-.84-1.48zm-5.16 9.55a9.16 9.16 0 00-10.55 2.82 9.05 9.05 0 00-1.62 9.36 33 33 0 01-7.63 3.16 9.36 9.36 0 00-8.75-5.5h-.14a9.5 9.5 0 00-8.38 5.54 32.24 32.24 0 01-7.63-3.12 9.06 9.06 0 00-2.32-10 9.11 9.11 0 00-10-2.08 32.48 32.48 0 01-3.2-7.57 9.1 9.1 0 005.67-8.91 9.08 9.08 0 00-5.69-8.44 32.5 32.5 0 013.09-7.62 9.08 9.08 0 0010.23-2.2 9 9 0 002-10.17 32.73 32.73 0 017.6-3.18 9.12 9.12 0 009.53 5.71 9 9 0 007.93-5.75 32.76 32.76 0 017.61 3.14 9.09 9.09 0 002.15 10.24 9.08 9.08 0 0010.19 2.07 37.24 37.24 0 013.13 7.6 9.49 9.49 0 00-.06 17.33 32.18 32.18 0 01-3.16 7.57z\" />\n      <path d=\"M49.987 32.934a17.09 17.09 0 1017.08 17.08 17.1 17.1 0 00-17.08-17.08zm0 32.67a15.59 15.59 0 1115.58-15.59 15.61 15.61 0 01-15.58 15.59z\" />\n    </svg>\n  )\n}\n\nexport default SvgStrokeSettings\n","import React from 'react'\nimport { connect } from 'redux-bundler-react'\nimport { withTranslation } from 'react-i18next'\nimport classnames from 'classnames'\nimport ipfsLogoTextVert from './ipfs-logo-text-vert.svg'\nimport ipfsLogoTextHoriz from './ipfs-logo-text-horiz.svg'\nimport StrokeMarketing from '../icons/StrokeMarketing'\nimport StrokeWeb from '../icons/StrokeWeb'\nimport StrokeCube from '../icons/StrokeCube'\nimport StrokeSettings from '../icons/StrokeSettings'\nimport StrokeIpld from '../icons/StrokeIpld'\n\n// Styles\nimport './NavBar.css'\n\nconst NavLink = ({\n  to,\n  icon,\n  alternative,\n  disabled,\n  children\n}) => {\n  const Svg = icon\n  const { hash } = window.location\n  const href = `#${to}`\n  const active = alternative\n    ? hash === href || hash.startsWith(`${href}${alternative}`)\n    : hash && hash.startsWith(href)\n  const anchorClass = classnames({\n    'bg-white-10 navbar-item-active': active,\n    'o-50 no-pointer-events': disabled\n  }, ['navbar-item dib db-l pt2 pb3 pv1-l white no-underline f5 hover-bg-white-10 tc bb bw2 bw0-l b--navy'])\n  const svgClass = classnames({\n    'o-100': active,\n    'o-50': !active\n  }, ['fill-current-color'])\n\n  return (\n    // eslint-disable-next-line jsx-a11y/anchor-is-valid\n    <a href={disabled ? null : href} className={anchorClass} role='menuitem' title={children}>\n      <div className='db ph2 pv1'>\n        <div className='db'>\n          <Svg width='46' role='presentation' className={svgClass} />\n        </div>\n        <div className={`${active ? 'o-100' : 'o-50'} db f6 tc montserrat ttu fw1 `} style={{ whiteSpace: 'pre-wrap' }}>\n          {children}\n        </div>\n      </div>\n    </a>\n  )\n}\n\nexport const NavBar = ({ t }) => {\n  const codeUrl = 'https://github.com/ipfs/ipfs-webui'\n  const bugsUrl = `${codeUrl}/issues`\n  const gitRevision = process.env.REACT_APP_GIT_REV\n  const revisionUrl = `${codeUrl}/commit/${gitRevision}`\n  return (\n    <div className='h-100 fixed-l flex flex-column justify-between' style={{ overflowY: 'auto', width: 'inherit' }}>\n      <div className='flex flex-column'>\n        <a href=\"#/welcome\" role='menuitem' title={t('welcome:description')}>\n          <div className='pt3 pb1 pb2-l'>\n            <img className='navbar-logo-vert center db-l dn pt3 pb1' style={{ height: 94 }} src={ipfsLogoTextVert} alt='' />\n            <img className='navbar-logo-horiz center db dn-l' style={{ height: 70 }} src={ipfsLogoTextHoriz} alt='' />\n          </div>\n        </a>\n        <div className='db overflow-x-scroll overflow-x-hidden-l nowrap tc' role='menubar'>\n          <NavLink to='/' alternative=\"status\" icon={StrokeMarketing}>{t('status:title')}</NavLink>\n          <NavLink to='/files' icon={StrokeWeb}>{t('files:title')}</NavLink>\n          <NavLink to='/explore' icon={StrokeIpld}>{t('explore:tabName')}</NavLink>\n          <NavLink to='/peers' icon={StrokeCube}>{t('peers:title')}</NavLink>\n          <NavLink to='/settings' icon={StrokeSettings}>{t('settings:title')}</NavLink>\n        </div>\n      </div>\n      <div className='dn db-l navbar-footer mb2 tc center f7 o-80 glow'>\n        { gitRevision && <div className='mb1'>\n          <a className='link white' href={revisionUrl} target='_blank' rel='noopener noreferrer'>{t('app:terms.revision')} {gitRevision}</a>\n        </div> }\n        <div className='mb1'>\n          <a className='link white' href={codeUrl} target='_blank' rel='noopener noreferrer'>{t('app:nav.codeLink')}</a>\n        </div>\n        <div>\n          <a className='link white' href={bugsUrl} target='_blank' rel='noopener noreferrer'>{t('app:nav.bugsLink')}</a>\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default connect(\n  withTranslation()(NavBar)\n)\n","import React from 'react'\nimport CancelIcon from '../../icons/GlyphSmallCancel'\n\nconst Toast = ({ error, children, onDismiss }) => {\n  const bg = error ? 'bg-yellow' : 'bg-green'\n  return (\n    <div className='fixed bottom-0 tc pb2 z-max' style={{ left: '50% ', transform: 'translateX(-50%)' }}>\n      <div className={`flex items-center f5 lh-copy avenir pl2 pl4-ns pv2 white br2 ${bg}`}>\n        {children}\n        <CancelIcon\n          className='fill-current-color ph3 glow o-80 pointer'\n          style={{ height: '28px', transform: 'scale(1.5)' }}\n          onClick={onDismiss} />\n      </div>\n    </div>\n  )\n}\n\nexport default Toast\n","import React from 'react'\nimport { connect } from 'redux-bundler-react'\nimport { withTranslation } from 'react-i18next'\nimport Toast from './Toast'\n\nconst Notify = ({ t, notify, notifyI18nKey, doNotifyDismiss }) => {\n  const { show, error, msgArgs } = notify\n  if (!show) return null\n\n  return (\n    <Toast error={error} onDismiss={doNotifyDismiss}>\n      {t(notifyI18nKey, msgArgs)}\n    </Toast>\n  )\n}\n\nexport default connect(\n  'selectNotify',\n  'selectNotifyI18nKey',\n  'doNotifyDismiss',\n  withTranslation('notify')(Notify)\n)\n","import React from 'react'\nimport { connect } from 'redux-bundler-react'\nimport { withTranslation } from 'react-i18next'\n\nconst pickColor = (ipfsReady, ipfsConnected) => {\n  if (ipfsReady && ipfsConnected) return 'teal'\n  if (ipfsReady) return 'red'\n  return 'gray'\n}\n\nconst pickTitleKey = (ipfsReady, ipfsConnected) => {\n  if (ipfsReady && ipfsConnected) return 'app:status.connectedToIpfs'\n  if (ipfsReady) return 'ipfsApiRequestFailed'\n  return 'app:status.connectingToIpfs'\n}\n\nexport const Connected = ({ t, className, size = 28, ipfsReady, ipfsConnected, doSetIsNodeInfoOpen }) => {\n  const title = t(pickTitleKey(ipfsReady, ipfsConnected))\n  const fill = pickColor(ipfsReady, ipfsConnected)\n  const opacity = ipfsConnected ? 'o-60' : 'o-100'\n\n  return (\n    <a title={title} className={`dib ${className}`} href='#/status' onClick={() => doSetIsNodeInfoOpen(true)}>\n      <svg className={`${fill} ${opacity} fill-current-color transition-all glow`} viewBox='0 0 24 24' width={size} height={size} aria-hidden=\"true\">\n        <path d='M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM6.5 9L10 5.5 13.5 9H11v4H9V9H6.5zm11 6L14 18.5 10.5 15H13v-4h2v4h2.5z ' />\n      </svg>\n    </a>\n  )\n}\n\nexport default connect(\n  'selectIpfsReady',\n  'selectIpfsConnected',\n  'doSetIsNodeInfoOpen',\n  withTranslation('notify')(Connected)\n)\n","import React from 'react'\nimport { connect } from 'redux-bundler-react'\nimport { withTranslation } from 'react-i18next'\n\nexport const TourHelper = ({ doEnableTours, className = '', size = 23, t }) => {\n  const handleClick = () => {\n    doEnableTours()\n  }\n\n  return (\n    <button className={`dib mr1 ml4-m pointer ${className}`} onClick={handleClick} aria-label={ t('startTourHelper')}>\n      <svg className='fill-teal o-60 glow' viewBox='0 0 44 44' width={size} height={size} aria-hidden=\"true\">\n        <path d='m22,0c-12.2,0-22,9.8-22,22s9.8,22 22,22 22-9.8 22-22-9.8-22-22-22zm2,34c0,0.6-0.4,1-1,1h-2c-0.6,0-1-0.4-1-1v-2c0-0.6 0.4-1 1-1h2c0.6,0 1,0.4 1,1v2zm2.7-8.9c-1.4,1.2-2.4,2-2.7,3.1-0.1,0.5-0.5,0.8-1,0.8h-2c-0.6,0-1.1-0.5-1-1.1 0.4-2.9 2.5-4.5 4.2-5.9 1.8-1.4 2.8-2.3 2.8-4 0-2.8-2.2-5-5-5s-5,2.2-5,5c0,0.2 0,0.4 0,0.6 0.1,0.5-0.2,1-0.7,1.1l-1.9,.6c-0.6,0.2-1.2-0.2-1.3-0.8-0.1-0.5-0.1-1-0.1-1.5 0-5 4-9 9-9s9,4 9,9c0,3.7-2.4,5.6-4.3,7.1z' />\n      </svg>\n    </button>\n  )\n}\n\nexport default connect(\n  'doEnableTours',\n  withTranslation('app')(TourHelper)\n)\n","import React from 'react'\nimport isIPFS from 'is-ipfs'\nimport PropTypes from 'prop-types'\nimport { withTranslation } from 'react-i18next'\nimport StrokeFolder from '../../icons/StrokeFolder'\nimport StrokeIpld from '../../icons/StrokeIpld'\nimport Button from '../../components/button/Button'\nimport './FilesExploreForm.css'\n\nclass FilesExploreForm extends React.Component {\n  constructor (props) {\n    super(props)\n    this.state = {\n      path: '',\n      hideExplore: false\n    }\n    this.onChange = this.onChange.bind(this)\n    this.onKeyDown = this.onKeyDown.bind(this)\n    this.onBrowse = this.onBrowse.bind(this)\n    this.onInspect = this.onInspect.bind(this)\n  }\n\n  onKeyDown (evt) {\n    if (evt.key === 'Enter') {\n      this.onBrowse(evt)\n    }\n  }\n\n  onBrowse (evt) {\n    evt.preventDefault()\n\n    if (this.isValid) {\n      let path = this.path\n\n      if (isIPFS.cid(path)) {\n        path = `/ipfs/${path}`\n      }\n\n      this.props.onBrowse({ path })\n      this.setState({ path: '' })\n    }\n  }\n\n  onInspect (evt) {\n    evt.preventDefault()\n\n    if (this.isValid) {\n      this.props.onInspect(this.path)\n      this.setState({ path: '' })\n    }\n  }\n\n  onChange (evt) {\n    const path = evt.target.value\n    this.setState({ path })\n  }\n\n  get path () {\n    return this.state.path.trim()\n  }\n\n  get isValid () {\n    return this.path !== '' && (isIPFS.cid(this.path) || isIPFS.path(this.path))\n  }\n\n  get inputClass () {\n    if (this.path === '') {\n      return 'focus-outline'\n    }\n\n    if (this.isValid) {\n      return 'b--green-muted focus-outline-green'\n    } else {\n      return 'b--red-muted focus-outline-red'\n    }\n  }\n\n  render () {\n    const { t } = this.props\n    return (\n      <div data-id='FilesExploreForm' className='sans-serif black-80 flex'>\n        <div className='flex-auto'>\n          <div className='relative'>\n            <input id='ipfs-path' className={`input-reset bn pa2 mb2 db w-100 f6 br-0 placeholder-light ${this.inputClass}`} style={{ borderRadius: '3px 0 0 3px' }} type='text' placeholder='QmHash/bafyHash' aria-describedby='ipfs-path-desc' onChange={this.onChange} onKeyDown={this.onKeyDown} value={this.state.path} />\n            <small id='ipfs-path-desc' className='o-0 absolute f6 black-60 db mb2'>Paste in a CID or IPFS path</small>\n          </div>\n        </div>\n        <div className='flex flex-row-reverse mb2'>\n          <Button\n            minWidth={0}\n            disabled={!this.isValid}\n            title={t('app:actions.inspect')}\n            style={{ borderRadius: '0 3px 3px 0' }}\n            onClick={this.onInspect}\n            bg='bg-teal'\n            className='ExploreFormButton button-reset pv1 ph2 ba f7 fw4 white overflow-hidden tc' >\n            <StrokeIpld style={{ height: '2em' }} className='dib fill-current-color v-mid' />\n            <span className='ml2'>{t('app:actions.inspect')}</span>\n          </Button>\n          <Button\n            minWidth={0}\n            disabled={!this.isValid}\n            style={{ borderRadius: '0' }}\n            title={t('app:actions.browse')}\n            onClick={this.onBrowse}\n            className='ExploreFormButton button-reset pv1 ph2 ba f7 fw4 white bg-gray overflow-hidden tc' >\n            <StrokeFolder style={{ height: '2em' }} className='dib fill-current-color v-mid' />\n            <span className='ml2'>{t('app:actions.browse')}</span>\n          </Button>\n        </div>\n      </div>\n    )\n  }\n}\n\nFilesExploreForm.propTypes = {\n  t: PropTypes.func.isRequired,\n  onInspect: PropTypes.func.isRequired,\n  onBrowse: PropTypes.func.isRequired\n}\n\nexport default withTranslation('files')(FilesExploreForm)\n","import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'redux-bundler-react'\nimport { getNavHelper } from 'internal-nav-helper'\nimport ReactJoyride from 'react-joyride'\nimport { withTranslation } from 'react-i18next'\nimport { normalizeFiles } from './lib/files'\n// React DnD\nimport { DropTarget } from 'react-dnd'\nimport { NativeTypes } from 'react-dnd-html5-backend'\n// Lib\nimport { appTour } from './lib/tours'\nimport { getJoyrideLocales } from './helpers/i8n'\n// Components\nimport NavBar from './navigation/NavBar'\nimport ComponentLoader from './loader/ComponentLoader'\nimport Notify from './components/notify/Notify'\nimport Connected from './components/connected/Connected'\nimport TourHelper from './components/tour/TourHelper'\nimport FilesExploreForm from './files/explore-form/FilesExploreForm'\n\nexport class App extends Component {\n  static propTypes = {\n    doTryInitIpfs: PropTypes.func.isRequired,\n    doUpdateUrl: PropTypes.func.isRequired,\n    doUpdateHash: PropTypes.func.isRequired,\n    doFilesWrite: PropTypes.func.isRequired,\n    routeInfo: PropTypes.object.isRequired,\n    filesPathInfo: PropTypes.object,\n    // Injected by DropTarget\n    isOver: PropTypes.bool.isRequired\n  }\n\n  componentDidMount () {\n    this.props.doTryInitIpfs()\n  }\n\n  addFiles = async (filesPromise) => {\n    const { doFilesWrite, doUpdateHash, routeInfo, filesPathInfo } = this.props\n    const isFilesPage = routeInfo.pattern === '/files*'\n    const addAtPath = isFilesPage ? (filesPathInfo?.realPath || routeInfo.params.path) : '/'\n    const files = await filesPromise\n\n    doFilesWrite(normalizeFiles(files), addAtPath)\n    // Change to the files pages if the user is not there\n    if (!isFilesPage) {\n      doUpdateHash('/files')\n    }\n  }\n\n  handleJoyrideCb = (data) => {\n    if (data.action === 'close') {\n      this.props.doDisableTooltip()\n    }\n  }\n\n  render () {\n    const { t, route: Page, ipfsReady, doFilesNavigateTo, doExploreUserProvidedPath, routeInfo: { url }, connectDropTarget, canDrop, isOver, showTooltip } = this.props\n    return connectDropTarget(\n      // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions\n      <div className='sans-serif h-100 relative' onClick={getNavHelper(this.props.doUpdateUrl)}>\n        {/* Tinted overlay that appears when dragging and dropping an item */}\n        { canDrop && isOver && <div className='h-100 top-0 right-0 fixed appOverlay' style={{ background: 'rgba(99, 202, 210, 0.2)' }} /> }\n        <div className='flex flex-row-reverse-l flex-column-reverse justify-end justify-start-l' style={{ minHeight: '100vh' }}>\n          <div className='flex-auto-l'>\n            <div className='flex items-center ph3 ph4-l' style={{ WebkitAppRegion: 'drag', height: 75, background: '#F0F6FA', paddingTop: '20px', paddingBottom: '15px' }}>\n              <div className='joyride-app-explore' style={{ width: 560 }}>\n                <FilesExploreForm onBrowse={doFilesNavigateTo} onInspect={doExploreUserProvidedPath} />\n              </div>\n              <div className='dn flex-ns flex-auto items-center justify-end'>\n                <TourHelper />\n                <Connected className='joyride-app-status' />\n              </div>\n            </div>\n            <main className='bg-white pv3 pa3 pa4-l'>\n              { (ipfsReady || url === '/welcome' || url.startsWith('/settings'))\n                ? <Page />\n                : <ComponentLoader />\n              }\n            </main>\n          </div>\n          <div className='navbar-container flex-none-l bg-navy'>\n            <NavBar />\n          </div>\n        </div>\n\n        <ReactJoyride\n          run={showTooltip}\n          steps={appTour.getSteps({ t })}\n          styles={appTour.styles}\n          callback={this.handleJoyrideCb}\n          scrollToFirstStep\n          disableOverlay\n          locale={getJoyrideLocales(t)}\n        />\n\n        <Notify />\n      </div>\n    )\n  }\n}\n\nconst dropTarget = {\n  drop: (props, monitor, App) => {\n    if (monitor.didDrop()) {\n      return\n    }\n\n    const { filesPromise } = monitor.getItem()\n    App.addFiles(filesPromise)\n  },\n  canDrop: (props) => props.filesPathInfo ? props.filesPathInfo.isMfs : true\n}\n\nconst dropCollect = (connect, monitor) => ({\n  connectDropTarget: connect.dropTarget(),\n  isOver: monitor.isOver(),\n  canDrop: monitor.canDrop()\n})\n\nexport const AppWithDropTarget = DropTarget(NativeTypes.FILE, dropTarget, dropCollect)(App)\n\nexport default connect(\n  'selectRoute',\n  'selectRouteInfo',\n  'selectIpfsReady',\n  'selectShowTooltip',\n  'doFilesNavigateTo',\n  'doExploreUserProvidedPath',\n  'doUpdateUrl',\n  'doUpdateHash',\n  'doTryInitIpfs',\n  'doFilesWrite',\n  'doDisableTooltip',\n  'selectFilesPathInfo',\n  withTranslation('app')(AppWithDropTarget)\n)\n","// Extracted from https://github.com/HenrikJoreteg/redux-bundler/blob/c1b8ce7629ee6c389f4155b3254e530bd09c868e/src/bundles/create-reactor-bundle.js\nimport { debounce, ric, raf } from 'redux-bundler'\n\nconst defaults = {\n  idleTimeout: 2000,\n  idleAction: 'APP_IDLE',\n  stopWhenTabInactive: false\n}\n\nconst ricOptions = { timeout: 500 }\n\nexport const getIdleDispatcher = (stopWhenInactive, timeout, fn) =>\n  debounce(() => {\n    // the requestAnimationFrame ensures it doesn't run when tab isn't active\n    stopWhenInactive ? raf(() => ric(fn, ricOptions)) : ric(fn, ricOptions)\n  }, timeout)\n\nconst createAppIdle = spec => ({\n  name: 'appIdle',\n\n  init: store => {\n    const opts = Object.assign({}, defaults, spec)\n    const { idleAction, idleTimeout } = opts\n    let idleDispatcher\n    if (idleTimeout) {\n      idleDispatcher = getIdleDispatcher(\n        opts.stopWhenTabInactive,\n        idleTimeout,\n        () => store.dispatch({ type: idleAction })\n      )\n    }\n\n    const callback = () => {\n      if (idleDispatcher) {\n        idleDispatcher()\n      }\n    }\n\n    store.subscribe(callback)\n    callback()\n  }\n})\nexport default createAppIdle\n","import { createSelector } from 'redux-bundler'\n\n// Depends on nodeBandwidthBundle\nfunction createNodeBandwidthChart (opts) {\n  opts = opts || {}\n  // Only store up to 1 day of data\n  opts.windowSize = opts.windowSize || 1000 * 60 * 60 * 24\n\n  return {\n    name: 'nodeBandwidthChart',\n\n    reducer (state = { data: { in: [], out: [] } }, action) {\n      if (action.type === 'NODE_BANDWIDTH_CHART_DATA_UPDATED') {\n        return { ...state, data: action.payload.chartData }\n      }\n\n      return state\n    },\n\n    selectNodeBandwidthChartData: state => state.nodeBandwidthChart.data,\n\n    doUpdateNodeBandwidthChartData: (bw, timestamp, chartData) => ({ dispatch }) => {\n      chartData = {\n        in: chartData.in.concat({ x: timestamp, y: parseInt(bw.rateIn.toFixed(0), 10) }),\n        out: chartData.out.concat({ x: timestamp, y: parseInt(bw.rateOut.toFixed(0) * -1, 10) })\n      }\n\n      const startIndex = chartData.in.findIndex(d => d.x >= timestamp - opts.windowSize)\n      if (startIndex > 0) {\n        chartData.in = chartData.in.slice(startIndex)\n        chartData.out = chartData.out.slice(startIndex)\n      }\n\n      dispatch({ type: 'NODE_BANDWIDTH_CHART_DATA_UPDATED', payload: { chartData } })\n    },\n\n    reactUpdateNodeBandwidthChartData: createSelector(\n      'selectNodeBandwidth',\n      'selectNodeBandwidthLastSuccess',\n      'selectNodeBandwidthEnabled',\n      'selectNodeBandwidthChartData',\n      (bw, lastSuccess, enabled, chartData) => {\n        if (!bw || !enabled) return\n\n        // Only tests for .in because it has the same timestamps as .out\n        if (!chartData.in.length || lastSuccess > chartData.in[chartData.in.length - 1].x) {\n          return {\n            actionCreator: 'doUpdateNodeBandwidthChartData',\n            args: [bw, lastSuccess, chartData]\n          }\n        }\n      }\n    )\n  }\n}\nexport default createNodeBandwidthChart\n","import { createAsyncResourceBundle, createSelector } from 'redux-bundler'\nimport ms from 'milliseconds'\nimport last from 'it-last'\n\nconst bundle = createAsyncResourceBundle({\n  name: 'nodeBandwidth',\n  actionBaseType: 'NODE_BANDWIDTH',\n  getPromise: async ({ getIpfs }) => {\n    try {\n      const stats = await last(getIpfs().stats.bw())\n      return stats\n    } catch (err) {\n      if (/bandwidth reporter disabled in config/.test(err)) {\n        return { disabled: true }\n      }\n\n      throw err\n    }\n  },\n  staleAfter: ms.seconds(3),\n  retryAfter: ms.seconds(3),\n  persist: false,\n  checkIfOnline: false\n})\n\nbundle.selectNodeBandwidthEnabled = state => state.nodeBandwidth.data ? !state.nodeBandwidth.data.disabled : false\n\nbundle.selectNodeBandwidthLastSuccess = state => state.nodeBandwidth.lastSuccess\n\n// Update the node bandwidth if it is stale (appTime - lastSuccess > staleAfter)\nbundle.reactNodeBandwidthFetchWhenIdle = createSelector(\n  'selectNodeBandwidthShouldUpdate',\n  'selectIpfsReady',\n  (shouldUpdate, ipfsReady) => {\n    if (shouldUpdate && ipfsReady) {\n      return { actionCreator: 'doFetchNodeBandwidth' }\n    }\n  }\n)\n\nexport default bundle\n","import { createAsyncResourceBundle, createSelector } from 'redux-bundler'\nimport ms from 'milliseconds'\nimport multiaddr from 'multiaddr'\n\nconst swarmPeersTTL = ms.seconds(10)\nconst bundle = createAsyncResourceBundle({\n  name: 'peers',\n  actionBaseType: 'PEERS',\n  getPromise: ({ getIpfs }) => getIpfs().swarm.peers({ verbose: true, timeout: swarmPeersTTL }),\n  staleAfter: swarmPeersTTL,\n  persist: false,\n  checkIfOnline: false\n})\n\nconst asyncResourceReducer = bundle.reducer\n\nbundle.reducer = (state, action) => {\n  const asyncResult = asyncResourceReducer(state, action)\n\n  if (action.type === 'SET_SELECTED_PEER') {\n    return { ...asyncResult, selectedPeers: action.payload }\n  }\n\n  return asyncResult\n}\n\nbundle.selectPeersCount = createSelector(\n  'selectPeers',\n  (peers) => {\n    if (!Array.isArray(peers)) return 0\n    return peers.length\n  }\n)\n\nbundle.doConnectSwarm = (addr, permanent) => async ({ dispatch, getIpfs, store }) => {\n  dispatch({ type: 'SWARM_CONNECT_STARTED', payload: { addr } })\n  const ipfs = getIpfs()\n\n  try {\n    await ipfs.swarm.connect(addr)\n\n    if (permanent) {\n      const maddr = multiaddr(addr)\n      const peerId = maddr.getPeerId()\n      const rawAddr = maddr.decapsulateCode(421).toString() // drop /p2p suffix\n\n      // TODO: switch to ipfs.swarm.peering when https://github.com/ipfs/kubo/pull/8147 ships\n      let peers = (await ipfs.config.get('Peering.Peers')) || []\n      const preexisting = peers.find(p => p.ID === peerId)\n      if (preexisting) {\n        if (!preexisting.Addrs.find(a => a === rawAddr)) {\n          // add new addr to existing address list for the peer\n          preexisting.Addrs.push(rawAddr)\n        }\n      } else {\n        // add new peer to the list\n        peers = [...peers, { ID: peerId, Addrs: [rawAddr] }]\n      }\n\n      await ipfs.config.set('Peering.Peers', peers)\n      await store.doMarkConfigAsOutdated() // force Settings screen to re-fetch\n    }\n  } catch (err) {\n    return dispatch({\n      type: 'SWARM_CONNECT_FAILED',\n      payload: { addr, error: err }\n    })\n  }\n\n  return dispatch({ type: 'SWARM_CONNECT_FINISHED', payload: { addr } })\n}\n\n// Update the peers if they are stale (appTime - lastSuccess > staleAfter)\nbundle.reactPeersFetchWhenIdle = createSelector(\n  'selectPeersShouldUpdate',\n  'selectIpfsConnected',\n  (shouldUpdate, ipfsConnected) => {\n    if (shouldUpdate && ipfsConnected) {\n      return { actionCreator: 'doFetchPeers' }\n    }\n  }\n)\n\n// Get the peers frequently when we're on the peers page\nbundle.reactPeersFetchWhenActive = createSelector(\n  'selectAppTime',\n  'selectRouteInfo',\n  'selectPeersRaw',\n  'selectIpfsConnected',\n  (appTime, routeInfo, peersInfo, selectIpfsReady, ipfsConnected) => {\n    const lastSuccess = peersInfo.lastSuccess || 0\n    if (routeInfo.url === '/peers' && ipfsConnected && !peersInfo.isLoading && appTime - lastSuccess > ms.seconds(5)) {\n      return { actionCreator: 'doFetchPeers' }\n    }\n  }\n)\n\nbundle.selectSelectedPeers = (state) => state.peers.selectedPeers\n\nbundle.doSetSelectedPeers = (peer) => ({ dispatch }) => {\n  dispatch({ type: 'SET_SELECTED_PEER', payload: peer })\n}\n\nexport default bundle\n","/**\n * https://bugs.webkit.org/show_bug.cgi?id=226547\n * Safari has a horrible bug where IDB requests can hang while the browser is starting up.\n * The only solution is to keep nudging it until it's awake.\n * This probably creates garbage, but garbage is better than totally failing.\n */\nfunction idbReady() {\n    const isSafari = !navigator.userAgentData &&\n        /Safari\\//.test(navigator.userAgent) &&\n        !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    // No point putting other browsers or older versions of Safari through this mess.\n    if (!isSafari || !indexedDB.databases)\n        return Promise.resolve();\n    let intervalId;\n    return new Promise((resolve) => {\n        const tryIdb = () => indexedDB.databases().finally(resolve);\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(() => clearInterval(intervalId));\n}\n\nfunction promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n        // @ts-ignore - file size hacks\n        request.oncomplete = request.onsuccess = () => resolve(request.result);\n        // @ts-ignore - file size hacks\n        request.onabort = request.onerror = () => reject(request.error);\n    });\n}\nfunction createStore(dbName, storeName) {\n    const dbp = idbReady().then(() => {\n        const request = indexedDB.open(dbName);\n        request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n        return promisifyRequest(request);\n    });\n    return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));\n}\nlet defaultGetStoreFunc;\nfunction defaultGetStore() {\n    if (!defaultGetStoreFunc) {\n        defaultGetStoreFunc = createStore('keyval-store', 'keyval');\n    }\n    return defaultGetStoreFunc;\n}\n/**\n * Get a value by its key.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction get(key, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => promisifyRequest(store.get(key)));\n}\n/**\n * Set a value with a key.\n *\n * @param key\n * @param value\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction set(key, value, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.put(value, key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Set multiple values at once. This is faster than calling set() multiple times.\n * It's also atomic – if one of the pairs can't be added, none will be added.\n *\n * @param entries Array of entries, where each entry is an array of `[key, value]`.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction setMany(entries, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        entries.forEach((entry) => store.put(entry[1], entry[0]));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Get multiple values by their keys\n *\n * @param keys\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction getMany(keys, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => Promise.all(keys.map((key) => promisifyRequest(store.get(key)))));\n}\n/**\n * Update a value. This lets you see the old value and update it as an atomic operation.\n *\n * @param key\n * @param updater A callback that takes the old value and returns a new value.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction update(key, updater, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => \n    // Need to create the promise manually.\n    // If I try to chain promises, the transaction closes in browsers\n    // that use a promise polyfill (IE10/11).\n    new Promise((resolve, reject) => {\n        store.get(key).onsuccess = function () {\n            try {\n                store.put(updater(this.result), key);\n                resolve(promisifyRequest(store.transaction));\n            }\n            catch (err) {\n                reject(err);\n            }\n        };\n    }));\n}\n/**\n * Delete a particular key from the store.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction del(key, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.delete(key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Clear all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction clear(customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.clear();\n        return promisifyRequest(store.transaction);\n    });\n}\nfunction eachCursor(customStore, callback) {\n    return customStore('readonly', (store) => {\n        // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.\n        // And openKeyCursor isn't supported by Safari.\n        store.openCursor().onsuccess = function () {\n            if (!this.result)\n                return;\n            callback(this.result);\n            this.result.continue();\n        };\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Get all keys in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction keys(customStore = defaultGetStore()) {\n    const items = [];\n    return eachCursor(customStore, (cursor) => items.push(cursor.key)).then(() => items);\n}\n/**\n * Get all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction values(customStore = defaultGetStore()) {\n    const items = [];\n    return eachCursor(customStore, (cursor) => items.push(cursor.value)).then(() => items);\n}\n/**\n * Get all entries in the store. Each entry is an array of `[key, value]`.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction entries(customStore = defaultGetStore()) {\n    const items = [];\n    return eachCursor(customStore, (cursor) => items.push([cursor.key, cursor.value])).then(() => items);\n}\n\nvar idbKeyVal = {\n    __proto__: null,\n    clear: clear,\n    createStore: createStore,\n    del: del,\n    entries: entries,\n    get: get,\n    getMany: getMany,\n    keys: keys,\n    promisifyRequest: promisifyRequest,\n    set: set,\n    setMany: setMany,\n    update: update,\n    values: values\n};\n\nvar defaultOpts = {\n  maxAge: Infinity,\n  version: 0,\n  lib: idbKeyVal\n};\n\nvar getOpts = function getOpts(passedOptions) {\n  return Object.assign({}, defaultOpts, passedOptions);\n};\n\nvar keyValLib = idbKeyVal;\n\nvar _get = function get(key, opts, store) {\n  var _getOpts = getOpts(opts),\n      maxAge = _getOpts.maxAge,\n      version = _getOpts.version,\n      lib = _getOpts.lib;\n\n  return lib.get(key, store).then(JSON.parse).then(function (parsed) {\n    var age = Date.now() - parsed.time;\n\n    if (age > maxAge || version !== parsed.version) {\n      lib.del(key, store);\n      return null;\n    }\n\n    return parsed.data;\n  })[\"catch\"](function () {\n    return null;\n  });\n};\n\nvar _set = function set(key, data, spec, store) {\n  var _getOpts2 = getOpts(spec),\n      lib = _getOpts2.lib,\n      version = _getOpts2.version;\n\n  return lib.set(key, JSON.stringify({\n    version: version,\n    time: Date.now(),\n    data: data\n  }), store)[\"catch\"](function () {\n    return null;\n  });\n};\n\nvar _getAll = function getAll(spec, store) {\n  var opts = getOpts(spec);\n  var keys;\n  return opts.lib.keys(store).then(function (retrievedKeys) {\n    keys = retrievedKeys;\n    return Promise.all(keys.map(function (key) {\n      return _get(key, opts, store);\n    }));\n  }).then(function (data) {\n    return data.reduce(function (acc, bundleData, index) {\n      if (bundleData) {\n        acc[keys[index]] = bundleData;\n      }\n\n      return acc;\n    }, {});\n  })[\"catch\"](function () {});\n};\nvar getConfiguredCache = function getConfiguredCache(spec) {\n  var opts = getOpts(spec);\n  var store;\n\n  if (opts.name) {\n    store = createStore(opts.name, opts.name);\n  }\n\n  return {\n    get: function get(key) {\n      return _get(key, opts, store);\n    },\n    set: function set(key, val) {\n      return _set(key, val, opts, store);\n    },\n    getAll: function getAll() {\n      return _getAll(opts, store);\n    },\n    del: function del(key) {\n      return opts.lib.del(key, store);\n    },\n    clear: function clear() {\n      return opts.lib.clear(store);\n    },\n    keys: function keys() {\n      return opts.lib.keys(store);\n    }\n  };\n};\n\nexport { _get as get, _getAll as getAll, getConfiguredCache, keyValLib, _set as set };\n","var Cn=Object.create;var Nt=Object.defineProperty;var vn=Object.getOwnPropertyDescriptor;var Nn=Object.getOwnPropertyNames;var Rn=Object.getPrototypeOf,$n=Object.prototype.hasOwnProperty;var he=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports);var On=(t,e,r,n)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of Nn(e))!$n.call(t,i)&&i!==r&&Nt(t,i,{get:()=>e[i],enumerable:!(n=vn(e,i))||n.enumerable});return t};var Rt=(t,e,r)=>(r=t!=null?Cn(Rn(t)):{},On(e||!t||!t.__esModule?Nt(r,\"default\",{value:t,enumerable:!0}):r,t));var Dt=he(ze=>{\"use strict\";ze.byteLength=Hn;ze.toByteArray=Xn;ze.fromByteArray=Yn;var Q=[],q=[],Gn=typeof Uint8Array<\"u\"?Uint8Array:Array,ct=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";for(ae=0,$t=ct.length;ae<$t;++ae)Q[ae]=ct[ae],q[ct.charCodeAt(ae)]=ae;var ae,$t;q[\"-\".charCodeAt(0)]=62;q[\"_\".charCodeAt(0)]=63;function Ot(t){var e=t.length;if(e%4>0)throw new Error(\"Invalid string. Length must be a multiple of 4\");var r=t.indexOf(\"=\");r===-1&&(r=e);var n=r===e?0:4-r%4;return[r,n]}function Hn(t){var e=Ot(t),r=e[0],n=e[1];return(r+n)*3/4-n}function Wn(t,e,r){return(e+r)*3/4-r}function Xn(t){var e,r=Ot(t),n=r[0],i=r[1],o=new Gn(Wn(t,n,i)),s=0,a=i>0?n-4:n,d;for(d=0;d<a;d+=4)e=q[t.charCodeAt(d)]<<18|q[t.charCodeAt(d+1)]<<12|q[t.charCodeAt(d+2)]<<6|q[t.charCodeAt(d+3)],o[s++]=e>>16&255,o[s++]=e>>8&255,o[s++]=e&255;return i===2&&(e=q[t.charCodeAt(d)]<<2|q[t.charCodeAt(d+1)]>>4,o[s++]=e&255),i===1&&(e=q[t.charCodeAt(d)]<<10|q[t.charCodeAt(d+1)]<<4|q[t.charCodeAt(d+2)]>>2,o[s++]=e>>8&255,o[s++]=e&255),o}function Kn(t){return Q[t>>18&63]+Q[t>>12&63]+Q[t>>6&63]+Q[t&63]}function Jn(t,e,r){for(var n,i=[],o=e;o<r;o+=3)n=(t[o]<<16&16711680)+(t[o+1]<<8&65280)+(t[o+2]&255),i.push(Kn(n));return i.join(\"\")}function Yn(t){for(var e,r=t.length,n=r%3,i=[],o=16383,s=0,a=r-n;s<a;s+=o)i.push(Jn(t,s,s+o>a?a:s+o));return n===1?(e=t[r-1],i.push(Q[e>>2]+Q[e<<4&63]+\"==\")):n===2&&(e=(t[r-2]<<8)+t[r-1],i.push(Q[e>>10]+Q[e>>4&63]+Q[e<<2&63]+\"=\")),i.join(\"\")}});var Mt=he(ut=>{ut.read=function(t,e,r,n,i){var o,s,a=i*8-n-1,d=(1<<a)-1,w=d>>1,l=-7,m=r?i-1:0,N=r?-1:1,R=t[e+m];for(m+=N,o=R&(1<<-l)-1,R>>=-l,l+=a;l>0;o=o*256+t[e+m],m+=N,l-=8);for(s=o&(1<<-l)-1,o>>=-l,l+=n;l>0;s=s*256+t[e+m],m+=N,l-=8);if(o===0)o=1-w;else{if(o===d)return s?NaN:(R?-1:1)*(1/0);s=s+Math.pow(2,n),o=o-w}return(R?-1:1)*s*Math.pow(2,o-n)};ut.write=function(t,e,r,n,i,o){var s,a,d,w=o*8-i-1,l=(1<<w)-1,m=l>>1,N=i===23?Math.pow(2,-24)-Math.pow(2,-77):0,R=n?0:o-1,B=n?1:-1,S=e<0||e===0&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,s=l):(s=Math.floor(Math.log(e)/Math.LN2),e*(d=Math.pow(2,-s))<1&&(s--,d*=2),s+m>=1?e+=N/d:e+=N*Math.pow(2,1-m),e*d>=2&&(s++,d/=2),s+m>=l?(a=0,s=l):s+m>=1?(a=(e*d-1)*Math.pow(2,i),s=s+m):(a=e*Math.pow(2,m-1)*Math.pow(2,i),s=0));i>=8;t[r+R]=a&255,R+=B,a/=256,i-=8);for(s=s<<i|a,w+=i;w>0;t[r+R]=s&255,R+=B,s/=256,w-=8);t[r+R-B]|=S*128}});var tr=he(we=>{\"use strict\";var at=Dt(),pe=Mt(),Pt=typeof Symbol==\"function\"&&typeof Symbol.for==\"function\"?Symbol.for(\"nodejs.util.inspect.custom\"):null;we.Buffer=u;we.SlowBuffer=ni;we.INSPECT_MAX_BYTES=50;var je=2147483647;we.kMaxLength=je;u.TYPED_ARRAY_SUPPORT=Qn();!u.TYPED_ARRAY_SUPPORT&&typeof console<\"u\"&&typeof console.error==\"function\"&&console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");function Qn(){try{let t=new Uint8Array(1),e={foo:function(){return 42}};return Object.setPrototypeOf(e,Uint8Array.prototype),Object.setPrototypeOf(t,e),t.foo()===42}catch{return!1}}Object.defineProperty(u.prototype,\"parent\",{enumerable:!0,get:function(){if(!!u.isBuffer(this))return this.buffer}});Object.defineProperty(u.prototype,\"offset\",{enumerable:!0,get:function(){if(!!u.isBuffer(this))return this.byteOffset}});function te(t){if(t>je)throw new RangeError('The value \"'+t+'\" is invalid for option \"size\"');let e=new Uint8Array(t);return Object.setPrototypeOf(e,u.prototype),e}function u(t,e,r){if(typeof t==\"number\"){if(typeof e==\"string\")throw new TypeError('The \"string\" argument must be of type string. Received type number');return dt(t)}return Vt(t,e,r)}u.poolSize=8192;function Vt(t,e,r){if(typeof t==\"string\")return ei(t,e);if(ArrayBuffer.isView(t))return ti(t);if(t==null)throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \"+typeof t);if(Z(t,ArrayBuffer)||t&&Z(t.buffer,ArrayBuffer)||typeof SharedArrayBuffer<\"u\"&&(Z(t,SharedArrayBuffer)||t&&Z(t.buffer,SharedArrayBuffer)))return lt(t,e,r);if(typeof t==\"number\")throw new TypeError('The \"value\" argument must not be of type number. Received type number');let n=t.valueOf&&t.valueOf();if(n!=null&&n!==t)return u.from(n,e,r);let i=ri(t);if(i)return i;if(typeof Symbol<\"u\"&&Symbol.toPrimitive!=null&&typeof t[Symbol.toPrimitive]==\"function\")return u.from(t[Symbol.toPrimitive](\"string\"),e,r);throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \"+typeof t)}u.from=function(t,e,r){return Vt(t,e,r)};Object.setPrototypeOf(u.prototype,Uint8Array.prototype);Object.setPrototypeOf(u,Uint8Array);function qt(t){if(typeof t!=\"number\")throw new TypeError('\"size\" argument must be of type number');if(t<0)throw new RangeError('The value \"'+t+'\" is invalid for option \"size\"')}function Zn(t,e,r){return qt(t),t<=0?te(t):e!==void 0?typeof r==\"string\"?te(t).fill(e,r):te(t).fill(e):te(t)}u.alloc=function(t,e,r){return Zn(t,e,r)};function dt(t){return qt(t),te(t<0?0:pt(t)|0)}u.allocUnsafe=function(t){return dt(t)};u.allocUnsafeSlow=function(t){return dt(t)};function ei(t,e){if((typeof e!=\"string\"||e===\"\")&&(e=\"utf8\"),!u.isEncoding(e))throw new TypeError(\"Unknown encoding: \"+e);let r=Gt(t,e)|0,n=te(r),i=n.write(t,e);return i!==r&&(n=n.slice(0,i)),n}function ft(t){let e=t.length<0?0:pt(t.length)|0,r=te(e);for(let n=0;n<e;n+=1)r[n]=t[n]&255;return r}function ti(t){if(Z(t,Uint8Array)){let e=new Uint8Array(t);return lt(e.buffer,e.byteOffset,e.byteLength)}return ft(t)}function lt(t,e,r){if(e<0||t.byteLength<e)throw new RangeError('\"offset\" is outside of buffer bounds');if(t.byteLength<e+(r||0))throw new RangeError('\"length\" is outside of buffer bounds');let n;return e===void 0&&r===void 0?n=new Uint8Array(t):r===void 0?n=new Uint8Array(t,e):n=new Uint8Array(t,e,r),Object.setPrototypeOf(n,u.prototype),n}function ri(t){if(u.isBuffer(t)){let e=pt(t.length)|0,r=te(e);return r.length===0||t.copy(r,0,0,e),r}if(t.length!==void 0)return typeof t.length!=\"number\"||wt(t.length)?te(0):ft(t);if(t.type===\"Buffer\"&&Array.isArray(t.data))return ft(t.data)}function pt(t){if(t>=je)throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\"+je.toString(16)+\" bytes\");return t|0}function ni(t){return+t!=t&&(t=0),u.alloc(+t)}u.isBuffer=function(e){return e!=null&&e._isBuffer===!0&&e!==u.prototype};u.compare=function(e,r){if(Z(e,Uint8Array)&&(e=u.from(e,e.offset,e.byteLength)),Z(r,Uint8Array)&&(r=u.from(r,r.offset,r.byteLength)),!u.isBuffer(e)||!u.isBuffer(r))throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');if(e===r)return 0;let n=e.length,i=r.length;for(let o=0,s=Math.min(n,i);o<s;++o)if(e[o]!==r[o]){n=e[o],i=r[o];break}return n<i?-1:i<n?1:0};u.isEncoding=function(e){switch(String(e).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return!0;default:return!1}};u.concat=function(e,r){if(!Array.isArray(e))throw new TypeError('\"list\" argument must be an Array of Buffers');if(e.length===0)return u.alloc(0);let n;if(r===void 0)for(r=0,n=0;n<e.length;++n)r+=e[n].length;let i=u.allocUnsafe(r),o=0;for(n=0;n<e.length;++n){let s=e[n];if(Z(s,Uint8Array))o+s.length>i.length?(u.isBuffer(s)||(s=u.from(s)),s.copy(i,o)):Uint8Array.prototype.set.call(i,s,o);else if(u.isBuffer(s))s.copy(i,o);else throw new TypeError('\"list\" argument must be an Array of Buffers');o+=s.length}return i};function Gt(t,e){if(u.isBuffer(t))return t.length;if(ArrayBuffer.isView(t)||Z(t,ArrayBuffer))return t.byteLength;if(typeof t!=\"string\")throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof t);let r=t.length,n=arguments.length>2&&arguments[2]===!0;if(!n&&r===0)return 0;let i=!1;for(;;)switch(e){case\"ascii\":case\"latin1\":case\"binary\":return r;case\"utf8\":case\"utf-8\":return ht(t).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return r*2;case\"hex\":return r>>>1;case\"base64\":return er(t).length;default:if(i)return n?-1:ht(t).length;e=(\"\"+e).toLowerCase(),i=!0}}u.byteLength=Gt;function ii(t,e,r){let n=!1;if((e===void 0||e<0)&&(e=0),e>this.length||((r===void 0||r>this.length)&&(r=this.length),r<=0)||(r>>>=0,e>>>=0,r<=e))return\"\";for(t||(t=\"utf8\");;)switch(t){case\"hex\":return pi(this,e,r);case\"utf8\":case\"utf-8\":return Wt(this,e,r);case\"ascii\":return hi(this,e,r);case\"latin1\":case\"binary\":return di(this,e,r);case\"base64\":return fi(this,e,r);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return yi(this,e,r);default:if(n)throw new TypeError(\"Unknown encoding: \"+t);t=(t+\"\").toLowerCase(),n=!0}}u.prototype._isBuffer=!0;function fe(t,e,r){let n=t[e];t[e]=t[r],t[r]=n}u.prototype.swap16=function(){let e=this.length;if(e%2!==0)throw new RangeError(\"Buffer size must be a multiple of 16-bits\");for(let r=0;r<e;r+=2)fe(this,r,r+1);return this};u.prototype.swap32=function(){let e=this.length;if(e%4!==0)throw new RangeError(\"Buffer size must be a multiple of 32-bits\");for(let r=0;r<e;r+=4)fe(this,r,r+3),fe(this,r+1,r+2);return this};u.prototype.swap64=function(){let e=this.length;if(e%8!==0)throw new RangeError(\"Buffer size must be a multiple of 64-bits\");for(let r=0;r<e;r+=8)fe(this,r,r+7),fe(this,r+1,r+6),fe(this,r+2,r+5),fe(this,r+3,r+4);return this};u.prototype.toString=function(){let e=this.length;return e===0?\"\":arguments.length===0?Wt(this,0,e):ii.apply(this,arguments)};u.prototype.toLocaleString=u.prototype.toString;u.prototype.equals=function(e){if(!u.isBuffer(e))throw new TypeError(\"Argument must be a Buffer\");return this===e?!0:u.compare(this,e)===0};u.prototype.inspect=function(){let e=\"\",r=we.INSPECT_MAX_BYTES;return e=this.toString(\"hex\",0,r).replace(/(.{2})/g,\"$1 \").trim(),this.length>r&&(e+=\" ... \"),\"<Buffer \"+e+\">\"};Pt&&(u.prototype[Pt]=u.prototype.inspect);u.prototype.compare=function(e,r,n,i,o){if(Z(e,Uint8Array)&&(e=u.from(e,e.offset,e.byteLength)),!u.isBuffer(e))throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(r===void 0&&(r=0),n===void 0&&(n=e?e.length:0),i===void 0&&(i=0),o===void 0&&(o=this.length),r<0||n>e.length||i<0||o>this.length)throw new RangeError(\"out of range index\");if(i>=o&&r>=n)return 0;if(i>=o)return-1;if(r>=n)return 1;if(r>>>=0,n>>>=0,i>>>=0,o>>>=0,this===e)return 0;let s=o-i,a=n-r,d=Math.min(s,a),w=this.slice(i,o),l=e.slice(r,n);for(let m=0;m<d;++m)if(w[m]!==l[m]){s=w[m],a=l[m];break}return s<a?-1:a<s?1:0};function Ht(t,e,r,n,i){if(t.length===0)return-1;if(typeof r==\"string\"?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,wt(r)&&(r=i?0:t.length-1),r<0&&(r=t.length+r),r>=t.length){if(i)return-1;r=t.length-1}else if(r<0)if(i)r=0;else return-1;if(typeof e==\"string\"&&(e=u.from(e,n)),u.isBuffer(e))return e.length===0?-1:Lt(t,e,r,n,i);if(typeof e==\"number\")return e=e&255,typeof Uint8Array.prototype.indexOf==\"function\"?i?Uint8Array.prototype.indexOf.call(t,e,r):Uint8Array.prototype.lastIndexOf.call(t,e,r):Lt(t,[e],r,n,i);throw new TypeError(\"val must be string, number or Buffer\")}function Lt(t,e,r,n,i){let o=1,s=t.length,a=e.length;if(n!==void 0&&(n=String(n).toLowerCase(),n===\"ucs2\"||n===\"ucs-2\"||n===\"utf16le\"||n===\"utf-16le\")){if(t.length<2||e.length<2)return-1;o=2,s/=2,a/=2,r/=2}function d(l,m){return o===1?l[m]:l.readUInt16BE(m*o)}let w;if(i){let l=-1;for(w=r;w<s;w++)if(d(t,w)===d(e,l===-1?0:w-l)){if(l===-1&&(l=w),w-l+1===a)return l*o}else l!==-1&&(w-=w-l),l=-1}else for(r+a>s&&(r=s-a),w=r;w>=0;w--){let l=!0;for(let m=0;m<a;m++)if(d(t,w+m)!==d(e,m)){l=!1;break}if(l)return w}return-1}u.prototype.includes=function(e,r,n){return this.indexOf(e,r,n)!==-1};u.prototype.indexOf=function(e,r,n){return Ht(this,e,r,n,!0)};u.prototype.lastIndexOf=function(e,r,n){return Ht(this,e,r,n,!1)};function oi(t,e,r,n){r=Number(r)||0;let i=t.length-r;n?(n=Number(n),n>i&&(n=i)):n=i;let o=e.length;n>o/2&&(n=o/2);let s;for(s=0;s<n;++s){let a=parseInt(e.substr(s*2,2),16);if(wt(a))return s;t[r+s]=a}return s}function si(t,e,r,n){return Ve(ht(e,t.length-r),t,r,n)}function ci(t,e,r,n){return Ve(xi(e),t,r,n)}function ui(t,e,r,n){return Ve(er(e),t,r,n)}function ai(t,e,r,n){return Ve(Ei(e,t.length-r),t,r,n)}u.prototype.write=function(e,r,n,i){if(r===void 0)i=\"utf8\",n=this.length,r=0;else if(n===void 0&&typeof r==\"string\")i=r,n=this.length,r=0;else if(isFinite(r))r=r>>>0,isFinite(n)?(n=n>>>0,i===void 0&&(i=\"utf8\")):(i=n,n=void 0);else throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");let o=this.length-r;if((n===void 0||n>o)&&(n=o),e.length>0&&(n<0||r<0)||r>this.length)throw new RangeError(\"Attempt to write outside buffer bounds\");i||(i=\"utf8\");let s=!1;for(;;)switch(i){case\"hex\":return oi(this,e,r,n);case\"utf8\":case\"utf-8\":return si(this,e,r,n);case\"ascii\":case\"latin1\":case\"binary\":return ci(this,e,r,n);case\"base64\":return ui(this,e,r,n);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return ai(this,e,r,n);default:if(s)throw new TypeError(\"Unknown encoding: \"+i);i=(\"\"+i).toLowerCase(),s=!0}};u.prototype.toJSON=function(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};function fi(t,e,r){return e===0&&r===t.length?at.fromByteArray(t):at.fromByteArray(t.slice(e,r))}function Wt(t,e,r){r=Math.min(t.length,r);let n=[],i=e;for(;i<r;){let o=t[i],s=null,a=o>239?4:o>223?3:o>191?2:1;if(i+a<=r){let d,w,l,m;switch(a){case 1:o<128&&(s=o);break;case 2:d=t[i+1],(d&192)===128&&(m=(o&31)<<6|d&63,m>127&&(s=m));break;case 3:d=t[i+1],w=t[i+2],(d&192)===128&&(w&192)===128&&(m=(o&15)<<12|(d&63)<<6|w&63,m>2047&&(m<55296||m>57343)&&(s=m));break;case 4:d=t[i+1],w=t[i+2],l=t[i+3],(d&192)===128&&(w&192)===128&&(l&192)===128&&(m=(o&15)<<18|(d&63)<<12|(w&63)<<6|l&63,m>65535&&m<1114112&&(s=m))}}s===null?(s=65533,a=1):s>65535&&(s-=65536,n.push(s>>>10&1023|55296),s=56320|s&1023),n.push(s),i+=a}return li(n)}var zt=4096;function li(t){let e=t.length;if(e<=zt)return String.fromCharCode.apply(String,t);let r=\"\",n=0;for(;n<e;)r+=String.fromCharCode.apply(String,t.slice(n,n+=zt));return r}function hi(t,e,r){let n=\"\";r=Math.min(t.length,r);for(let i=e;i<r;++i)n+=String.fromCharCode(t[i]&127);return n}function di(t,e,r){let n=\"\";r=Math.min(t.length,r);for(let i=e;i<r;++i)n+=String.fromCharCode(t[i]);return n}function pi(t,e,r){let n=t.length;(!e||e<0)&&(e=0),(!r||r<0||r>n)&&(r=n);let i=\"\";for(let o=e;o<r;++o)i+=bi[t[o]];return i}function yi(t,e,r){let n=t.slice(e,r),i=\"\";for(let o=0;o<n.length-1;o+=2)i+=String.fromCharCode(n[o]+n[o+1]*256);return i}u.prototype.slice=function(e,r){let n=this.length;e=~~e,r=r===void 0?n:~~r,e<0?(e+=n,e<0&&(e=0)):e>n&&(e=n),r<0?(r+=n,r<0&&(r=0)):r>n&&(r=n),r<e&&(r=e);let i=this.subarray(e,r);return Object.setPrototypeOf(i,u.prototype),i};function _(t,e,r){if(t%1!==0||t<0)throw new RangeError(\"offset is not uint\");if(t+e>r)throw new RangeError(\"Trying to access beyond buffer length\")}u.prototype.readUintLE=u.prototype.readUIntLE=function(e,r,n){e=e>>>0,r=r>>>0,n||_(e,r,this.length);let i=this[e],o=1,s=0;for(;++s<r&&(o*=256);)i+=this[e+s]*o;return i};u.prototype.readUintBE=u.prototype.readUIntBE=function(e,r,n){e=e>>>0,r=r>>>0,n||_(e,r,this.length);let i=this[e+--r],o=1;for(;r>0&&(o*=256);)i+=this[e+--r]*o;return i};u.prototype.readUint8=u.prototype.readUInt8=function(e,r){return e=e>>>0,r||_(e,1,this.length),this[e]};u.prototype.readUint16LE=u.prototype.readUInt16LE=function(e,r){return e=e>>>0,r||_(e,2,this.length),this[e]|this[e+1]<<8};u.prototype.readUint16BE=u.prototype.readUInt16BE=function(e,r){return e=e>>>0,r||_(e,2,this.length),this[e]<<8|this[e+1]};u.prototype.readUint32LE=u.prototype.readUInt32LE=function(e,r){return e=e>>>0,r||_(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216};u.prototype.readUint32BE=u.prototype.readUInt32BE=function(e,r){return e=e>>>0,r||_(e,4,this.length),this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])};u.prototype.readBigUInt64LE=se(function(e){e=e>>>0,ye(e,\"offset\");let r=this[e],n=this[e+7];(r===void 0||n===void 0)&&Fe(e,this.length-8);let i=r+this[++e]*2**8+this[++e]*2**16+this[++e]*2**24,o=this[++e]+this[++e]*2**8+this[++e]*2**16+n*2**24;return BigInt(i)+(BigInt(o)<<BigInt(32))});u.prototype.readBigUInt64BE=se(function(e){e=e>>>0,ye(e,\"offset\");let r=this[e],n=this[e+7];(r===void 0||n===void 0)&&Fe(e,this.length-8);let i=r*2**24+this[++e]*2**16+this[++e]*2**8+this[++e],o=this[++e]*2**24+this[++e]*2**16+this[++e]*2**8+n;return(BigInt(i)<<BigInt(32))+BigInt(o)});u.prototype.readIntLE=function(e,r,n){e=e>>>0,r=r>>>0,n||_(e,r,this.length);let i=this[e],o=1,s=0;for(;++s<r&&(o*=256);)i+=this[e+s]*o;return o*=128,i>=o&&(i-=Math.pow(2,8*r)),i};u.prototype.readIntBE=function(e,r,n){e=e>>>0,r=r>>>0,n||_(e,r,this.length);let i=r,o=1,s=this[e+--i];for(;i>0&&(o*=256);)s+=this[e+--i]*o;return o*=128,s>=o&&(s-=Math.pow(2,8*r)),s};u.prototype.readInt8=function(e,r){return e=e>>>0,r||_(e,1,this.length),this[e]&128?(255-this[e]+1)*-1:this[e]};u.prototype.readInt16LE=function(e,r){e=e>>>0,r||_(e,2,this.length);let n=this[e]|this[e+1]<<8;return n&32768?n|4294901760:n};u.prototype.readInt16BE=function(e,r){e=e>>>0,r||_(e,2,this.length);let n=this[e+1]|this[e]<<8;return n&32768?n|4294901760:n};u.prototype.readInt32LE=function(e,r){return e=e>>>0,r||_(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24};u.prototype.readInt32BE=function(e,r){return e=e>>>0,r||_(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]};u.prototype.readBigInt64LE=se(function(e){e=e>>>0,ye(e,\"offset\");let r=this[e],n=this[e+7];(r===void 0||n===void 0)&&Fe(e,this.length-8);let i=this[e+4]+this[e+5]*2**8+this[e+6]*2**16+(n<<24);return(BigInt(i)<<BigInt(32))+BigInt(r+this[++e]*2**8+this[++e]*2**16+this[++e]*2**24)});u.prototype.readBigInt64BE=se(function(e){e=e>>>0,ye(e,\"offset\");let r=this[e],n=this[e+7];(r===void 0||n===void 0)&&Fe(e,this.length-8);let i=(r<<24)+this[++e]*2**16+this[++e]*2**8+this[++e];return(BigInt(i)<<BigInt(32))+BigInt(this[++e]*2**24+this[++e]*2**16+this[++e]*2**8+n)});u.prototype.readFloatLE=function(e,r){return e=e>>>0,r||_(e,4,this.length),pe.read(this,e,!0,23,4)};u.prototype.readFloatBE=function(e,r){return e=e>>>0,r||_(e,4,this.length),pe.read(this,e,!1,23,4)};u.prototype.readDoubleLE=function(e,r){return e=e>>>0,r||_(e,8,this.length),pe.read(this,e,!0,52,8)};u.prototype.readDoubleBE=function(e,r){return e=e>>>0,r||_(e,8,this.length),pe.read(this,e,!1,52,8)};function O(t,e,r,n,i,o){if(!u.isBuffer(t))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(e>i||e<o)throw new RangeError('\"value\" argument is out of bounds');if(r+n>t.length)throw new RangeError(\"Index out of range\")}u.prototype.writeUintLE=u.prototype.writeUIntLE=function(e,r,n,i){if(e=+e,r=r>>>0,n=n>>>0,!i){let a=Math.pow(2,8*n)-1;O(this,e,r,n,a,0)}let o=1,s=0;for(this[r]=e&255;++s<n&&(o*=256);)this[r+s]=e/o&255;return r+n};u.prototype.writeUintBE=u.prototype.writeUIntBE=function(e,r,n,i){if(e=+e,r=r>>>0,n=n>>>0,!i){let a=Math.pow(2,8*n)-1;O(this,e,r,n,a,0)}let o=n-1,s=1;for(this[r+o]=e&255;--o>=0&&(s*=256);)this[r+o]=e/s&255;return r+n};u.prototype.writeUint8=u.prototype.writeUInt8=function(e,r,n){return e=+e,r=r>>>0,n||O(this,e,r,1,255,0),this[r]=e&255,r+1};u.prototype.writeUint16LE=u.prototype.writeUInt16LE=function(e,r,n){return e=+e,r=r>>>0,n||O(this,e,r,2,65535,0),this[r]=e&255,this[r+1]=e>>>8,r+2};u.prototype.writeUint16BE=u.prototype.writeUInt16BE=function(e,r,n){return e=+e,r=r>>>0,n||O(this,e,r,2,65535,0),this[r]=e>>>8,this[r+1]=e&255,r+2};u.prototype.writeUint32LE=u.prototype.writeUInt32LE=function(e,r,n){return e=+e,r=r>>>0,n||O(this,e,r,4,4294967295,0),this[r+3]=e>>>24,this[r+2]=e>>>16,this[r+1]=e>>>8,this[r]=e&255,r+4};u.prototype.writeUint32BE=u.prototype.writeUInt32BE=function(e,r,n){return e=+e,r=r>>>0,n||O(this,e,r,4,4294967295,0),this[r]=e>>>24,this[r+1]=e>>>16,this[r+2]=e>>>8,this[r+3]=e&255,r+4};function Xt(t,e,r,n,i){Zt(e,n,i,t,r,7);let o=Number(e&BigInt(4294967295));t[r++]=o,o=o>>8,t[r++]=o,o=o>>8,t[r++]=o,o=o>>8,t[r++]=o;let s=Number(e>>BigInt(32)&BigInt(4294967295));return t[r++]=s,s=s>>8,t[r++]=s,s=s>>8,t[r++]=s,s=s>>8,t[r++]=s,r}function Kt(t,e,r,n,i){Zt(e,n,i,t,r,7);let o=Number(e&BigInt(4294967295));t[r+7]=o,o=o>>8,t[r+6]=o,o=o>>8,t[r+5]=o,o=o>>8,t[r+4]=o;let s=Number(e>>BigInt(32)&BigInt(4294967295));return t[r+3]=s,s=s>>8,t[r+2]=s,s=s>>8,t[r+1]=s,s=s>>8,t[r]=s,r+8}u.prototype.writeBigUInt64LE=se(function(e,r=0){return Xt(this,e,r,BigInt(0),BigInt(\"0xffffffffffffffff\"))});u.prototype.writeBigUInt64BE=se(function(e,r=0){return Kt(this,e,r,BigInt(0),BigInt(\"0xffffffffffffffff\"))});u.prototype.writeIntLE=function(e,r,n,i){if(e=+e,r=r>>>0,!i){let d=Math.pow(2,8*n-1);O(this,e,r,n,d-1,-d)}let o=0,s=1,a=0;for(this[r]=e&255;++o<n&&(s*=256);)e<0&&a===0&&this[r+o-1]!==0&&(a=1),this[r+o]=(e/s>>0)-a&255;return r+n};u.prototype.writeIntBE=function(e,r,n,i){if(e=+e,r=r>>>0,!i){let d=Math.pow(2,8*n-1);O(this,e,r,n,d-1,-d)}let o=n-1,s=1,a=0;for(this[r+o]=e&255;--o>=0&&(s*=256);)e<0&&a===0&&this[r+o+1]!==0&&(a=1),this[r+o]=(e/s>>0)-a&255;return r+n};u.prototype.writeInt8=function(e,r,n){return e=+e,r=r>>>0,n||O(this,e,r,1,127,-128),e<0&&(e=255+e+1),this[r]=e&255,r+1};u.prototype.writeInt16LE=function(e,r,n){return e=+e,r=r>>>0,n||O(this,e,r,2,32767,-32768),this[r]=e&255,this[r+1]=e>>>8,r+2};u.prototype.writeInt16BE=function(e,r,n){return e=+e,r=r>>>0,n||O(this,e,r,2,32767,-32768),this[r]=e>>>8,this[r+1]=e&255,r+2};u.prototype.writeInt32LE=function(e,r,n){return e=+e,r=r>>>0,n||O(this,e,r,4,2147483647,-2147483648),this[r]=e&255,this[r+1]=e>>>8,this[r+2]=e>>>16,this[r+3]=e>>>24,r+4};u.prototype.writeInt32BE=function(e,r,n){return e=+e,r=r>>>0,n||O(this,e,r,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[r]=e>>>24,this[r+1]=e>>>16,this[r+2]=e>>>8,this[r+3]=e&255,r+4};u.prototype.writeBigInt64LE=se(function(e,r=0){return Xt(this,e,r,-BigInt(\"0x8000000000000000\"),BigInt(\"0x7fffffffffffffff\"))});u.prototype.writeBigInt64BE=se(function(e,r=0){return Kt(this,e,r,-BigInt(\"0x8000000000000000\"),BigInt(\"0x7fffffffffffffff\"))});function Jt(t,e,r,n,i,o){if(r+n>t.length)throw new RangeError(\"Index out of range\");if(r<0)throw new RangeError(\"Index out of range\")}function Yt(t,e,r,n,i){return e=+e,r=r>>>0,i||Jt(t,e,r,4,34028234663852886e22,-34028234663852886e22),pe.write(t,e,r,n,23,4),r+4}u.prototype.writeFloatLE=function(e,r,n){return Yt(this,e,r,!0,n)};u.prototype.writeFloatBE=function(e,r,n){return Yt(this,e,r,!1,n)};function Qt(t,e,r,n,i){return e=+e,r=r>>>0,i||Jt(t,e,r,8,17976931348623157e292,-17976931348623157e292),pe.write(t,e,r,n,52,8),r+8}u.prototype.writeDoubleLE=function(e,r,n){return Qt(this,e,r,!0,n)};u.prototype.writeDoubleBE=function(e,r,n){return Qt(this,e,r,!1,n)};u.prototype.copy=function(e,r,n,i){if(!u.isBuffer(e))throw new TypeError(\"argument should be a Buffer\");if(n||(n=0),!i&&i!==0&&(i=this.length),r>=e.length&&(r=e.length),r||(r=0),i>0&&i<n&&(i=n),i===n||e.length===0||this.length===0)return 0;if(r<0)throw new RangeError(\"targetStart out of bounds\");if(n<0||n>=this.length)throw new RangeError(\"Index out of range\");if(i<0)throw new RangeError(\"sourceEnd out of bounds\");i>this.length&&(i=this.length),e.length-r<i-n&&(i=e.length-r+n);let o=i-n;return this===e&&typeof Uint8Array.prototype.copyWithin==\"function\"?this.copyWithin(r,n,i):Uint8Array.prototype.set.call(e,this.subarray(n,i),r),o};u.prototype.fill=function(e,r,n,i){if(typeof e==\"string\"){if(typeof r==\"string\"?(i=r,r=0,n=this.length):typeof n==\"string\"&&(i=n,n=this.length),i!==void 0&&typeof i!=\"string\")throw new TypeError(\"encoding must be a string\");if(typeof i==\"string\"&&!u.isEncoding(i))throw new TypeError(\"Unknown encoding: \"+i);if(e.length===1){let s=e.charCodeAt(0);(i===\"utf8\"&&s<128||i===\"latin1\")&&(e=s)}}else typeof e==\"number\"?e=e&255:typeof e==\"boolean\"&&(e=Number(e));if(r<0||this.length<r||this.length<n)throw new RangeError(\"Out of range index\");if(n<=r)return this;r=r>>>0,n=n===void 0?this.length:n>>>0,e||(e=0);let o;if(typeof e==\"number\")for(o=r;o<n;++o)this[o]=e;else{let s=u.isBuffer(e)?e:u.from(e,i),a=s.length;if(a===0)throw new TypeError('The value \"'+e+'\" is invalid for argument \"value\"');for(o=0;o<n-r;++o)this[o+r]=s[o%a]}return this};var de={};function yt(t,e,r){de[t]=class extends r{constructor(){super(),Object.defineProperty(this,\"message\",{value:e.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${t}]`,this.stack,delete this.name}get code(){return t}set code(i){Object.defineProperty(this,\"code\",{configurable:!0,enumerable:!0,value:i,writable:!0})}toString(){return`${this.name} [${t}]: ${this.message}`}}}yt(\"ERR_BUFFER_OUT_OF_BOUNDS\",function(t){return t?`${t} is outside of buffer bounds`:\"Attempt to access memory outside buffer bounds\"},RangeError);yt(\"ERR_INVALID_ARG_TYPE\",function(t,e){return`The \"${t}\" argument must be of type number. Received type ${typeof e}`},TypeError);yt(\"ERR_OUT_OF_RANGE\",function(t,e,r){let n=`The value of \"${t}\" is out of range.`,i=r;return Number.isInteger(r)&&Math.abs(r)>2**32?i=jt(String(r)):typeof r==\"bigint\"&&(i=String(r),(r>BigInt(2)**BigInt(32)||r<-(BigInt(2)**BigInt(32)))&&(i=jt(i)),i+=\"n\"),n+=` It must be ${e}. Received ${i}`,n},RangeError);function jt(t){let e=\"\",r=t.length,n=t[0]===\"-\"?1:0;for(;r>=n+4;r-=3)e=`_${t.slice(r-3,r)}${e}`;return`${t.slice(0,r)}${e}`}function wi(t,e,r){ye(e,\"offset\"),(t[e]===void 0||t[e+r]===void 0)&&Fe(e,t.length-(r+1))}function Zt(t,e,r,n,i,o){if(t>r||t<e){let s=typeof e==\"bigint\"?\"n\":\"\",a;throw o>3?e===0||e===BigInt(0)?a=`>= 0${s} and < 2${s} ** ${(o+1)*8}${s}`:a=`>= -(2${s} ** ${(o+1)*8-1}${s}) and < 2 ** ${(o+1)*8-1}${s}`:a=`>= ${e}${s} and <= ${r}${s}`,new de.ERR_OUT_OF_RANGE(\"value\",a,t)}wi(n,i,o)}function ye(t,e){if(typeof t!=\"number\")throw new de.ERR_INVALID_ARG_TYPE(e,\"number\",t)}function Fe(t,e,r){throw Math.floor(t)!==t?(ye(t,r),new de.ERR_OUT_OF_RANGE(r||\"offset\",\"an integer\",t)):e<0?new de.ERR_BUFFER_OUT_OF_BOUNDS:new de.ERR_OUT_OF_RANGE(r||\"offset\",`>= ${r?1:0} and <= ${e}`,t)}var mi=/[^+/0-9A-Za-z-_]/g;function gi(t){if(t=t.split(\"=\")[0],t=t.trim().replace(mi,\"\"),t.length<2)return\"\";for(;t.length%4!==0;)t=t+\"=\";return t}function ht(t,e){e=e||1/0;let r,n=t.length,i=null,o=[];for(let s=0;s<n;++s){if(r=t.charCodeAt(s),r>55295&&r<57344){if(!i){if(r>56319){(e-=3)>-1&&o.push(239,191,189);continue}else if(s+1===n){(e-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(e-=3)>-1&&o.push(239,191,189),i=r;continue}r=(i-55296<<10|r-56320)+65536}else i&&(e-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((e-=1)<0)break;o.push(r)}else if(r<2048){if((e-=2)<0)break;o.push(r>>6|192,r&63|128)}else if(r<65536){if((e-=3)<0)break;o.push(r>>12|224,r>>6&63|128,r&63|128)}else if(r<1114112){if((e-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,r&63|128)}else throw new Error(\"Invalid code point\")}return o}function xi(t){let e=[];for(let r=0;r<t.length;++r)e.push(t.charCodeAt(r)&255);return e}function Ei(t,e){let r,n,i,o=[];for(let s=0;s<t.length&&!((e-=2)<0);++s)r=t.charCodeAt(s),n=r>>8,i=r%256,o.push(i),o.push(n);return o}function er(t){return at.toByteArray(gi(t))}function Ve(t,e,r,n){let i;for(i=0;i<n&&!(i+r>=e.length||i>=t.length);++i)e[i+r]=t[i];return i}function Z(t,e){return t instanceof e||t!=null&&t.constructor!=null&&t.constructor.name!=null&&t.constructor.name===e.name}function wt(t){return t!==t}var bi=function(){let t=\"0123456789abcdef\",e=new Array(256);for(let r=0;r<16;++r){let n=r*16;for(let i=0;i<16;++i)e[n+i]=t[r]+t[i]}return e}();function se(t){return typeof BigInt>\"u\"?Bi:t}function Bi(){throw new Error(\"BigInt not supported\")}});var rr=he(()=>{});var ir=he(nr=>{var g=nr,{Buffer:qe}=tr(),Ai=rr();g.toBuffer=function(t,e,r){r=~~r;let n;if(this.isV4Format(t))n=e||qe.alloc(r+4),t.split(/\\./g).map(i=>{n[r++]=parseInt(i,10)&255});else if(this.isV6Format(t)){let i=t.split(\":\",8),o;for(o=0;o<i.length;o++){let s=this.isV4Format(i[o]),a;s&&(a=this.toBuffer(i[o]),i[o]=a.slice(0,2).toString(\"hex\")),a&&++o<8&&i.splice(o,0,a.slice(2,4).toString(\"hex\"))}if(i[0]===\"\")for(;i.length<8;)i.unshift(\"0\");else if(i[i.length-1]===\"\")for(;i.length<8;)i.push(\"0\");else if(i.length<8){for(o=0;o<i.length&&i[o]!==\"\";o++);let s=[o,1];for(o=9-i.length;o>0;o--)s.push(\"0\");i.splice(...s)}for(n=e||qe.alloc(r+16),o=0;o<i.length;o++){let s=parseInt(i[o],16);n[r++]=s>>8&255,n[r++]=s&255}}if(!n)throw Error(`Invalid ip address: ${t}`);return n};g.toString=function(t,e,r){e=~~e,r=r||t.length-e;let n=[];if(r===4){for(let i=0;i<r;i++)n.push(t[e+i]);n=n.join(\".\")}else if(r===16){for(let i=0;i<r;i+=2)n.push(t.readUInt16BE(e+i).toString(16));n=n.join(\":\"),n=n.replace(/(^|:)0(:0)*:0(:|$)/,\"$1::$3\"),n=n.replace(/:{3,4}/,\"::\")}return n};var Ii=/^(\\d{1,3}\\.){3,3}\\d{1,3}$/,Ui=/^(::)?(((\\d{1,3}\\.){3}(\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;g.isV4Format=function(t){return Ii.test(t)};g.isV6Format=function(t){return Ui.test(t)};function ke(t){return t===4?\"ipv4\":t===6?\"ipv6\":t?t.toLowerCase():\"ipv4\"}g.fromPrefixLen=function(t,e){t>32?e=\"ipv6\":e=ke(e);let r=4;e===\"ipv6\"&&(r=16);let n=qe.alloc(r);for(let i=0,o=n.length;i<o;++i){let s=8;t<8&&(s=t),t-=s,n[i]=~(255>>s)&255}return g.toString(n)};g.mask=function(t,e){t=g.toBuffer(t),e=g.toBuffer(e);let r=qe.alloc(Math.max(t.length,e.length)),n;if(t.length===e.length)for(n=0;n<t.length;n++)r[n]=t[n]&e[n];else if(e.length===4)for(n=0;n<e.length;n++)r[n]=t[t.length-4+n]&e[n];else{for(n=0;n<r.length-6;n++)r[n]=0;for(r[10]=255,r[11]=255,n=0;n<t.length;n++)r[n+12]=t[n]&e[n+12];n+=12}for(;n<r.length;n++)r[n]=0;return g.toString(r)};g.cidr=function(t){let e=t.split(\"/\"),r=e[0];if(e.length!==2)throw new Error(`invalid CIDR subnet: ${r}`);let n=g.fromPrefixLen(parseInt(e[1],10));return g.mask(r,n)};g.subnet=function(t,e){let r=g.toLong(g.mask(t,e)),n=g.toBuffer(e),i=0;for(let s=0;s<n.length;s++)if(n[s]===255)i+=8;else{let a=n[s]&255;for(;a;)a=a<<1&255,i++}let o=2**(32-i);return{networkAddress:g.fromLong(r),firstAddress:o<=2?g.fromLong(r):g.fromLong(r+1),lastAddress:o<=2?g.fromLong(r+o-1):g.fromLong(r+o-2),broadcastAddress:g.fromLong(r+o-1),subnetMask:e,subnetMaskLength:i,numHosts:o<=2?o:o-2,length:o,contains(s){return r===g.toLong(g.mask(s,e))}}};g.cidrSubnet=function(t){let e=t.split(\"/\"),r=e[0];if(e.length!==2)throw new Error(`invalid CIDR subnet: ${r}`);let n=g.fromPrefixLen(parseInt(e[1],10));return g.subnet(r,n)};g.not=function(t){let e=g.toBuffer(t);for(let r=0;r<e.length;r++)e[r]=255^e[r];return g.toString(e)};g.or=function(t,e){if(t=g.toBuffer(t),e=g.toBuffer(e),t.length===e.length){for(let o=0;o<t.length;++o)t[o]|=e[o];return g.toString(t)}let r=t,n=e;e.length>t.length&&(r=e,n=t);let i=r.length-n.length;for(let o=i;o<r.length;++o)r[o]|=n[o-i];return g.toString(r)};g.isEqual=function(t,e){if(t=g.toBuffer(t),e=g.toBuffer(e),t.length===e.length){for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}if(e.length===4){let n=e;e=t,t=n}for(let n=0;n<10;n++)if(e[n]!==0)return!1;let r=e.readUInt16BE(10);if(r!==0&&r!==65535)return!1;for(let n=0;n<4;n++)if(t[n]!==e[n+12])return!1;return!0};g.isPrivate=function(t){return/^(::f{4}:)?10\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(t)||/^(::f{4}:)?192\\.168\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(t)||/^(::f{4}:)?172\\.(1[6-9]|2\\d|30|31)\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(t)||/^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(t)||/^(::f{4}:)?169\\.254\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(t)||/^f[cd][0-9a-f]{2}:/i.test(t)||/^fe80:/i.test(t)||/^::1$/.test(t)||/^::$/.test(t)};g.isPublic=function(t){return!g.isPrivate(t)};g.isLoopback=function(t){return/^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})/.test(t)||/^fe80::1$/.test(t)||/^::1$/.test(t)||/^::$/.test(t)};g.loopback=function(t){if(t=ke(t),t!==\"ipv4\"&&t!==\"ipv6\")throw new Error(\"family must be ipv4 or ipv6\");return t===\"ipv4\"?\"127.0.0.1\":\"fe80::1\"};g.address=function(t,e){let r=Ai.networkInterfaces();if(e=ke(e),t&&t!==\"private\"&&t!==\"public\"){let i=r[t].filter(o=>ke(o.family)===e);return i.length===0?void 0:i[0].address}let n=Object.keys(r).map(i=>{let o=r[i].filter(s=>(s.family=ke(s.family),s.family!==e||g.isLoopback(s.address)?!1:t?t===\"public\"?g.isPrivate(s.address):g.isPublic(s.address):!0));return o.length?o[0].address:void 0}).filter(Boolean);return n.length?n[0]:g.loopback(e)};g.toLong=function(t){let e=0;return t.split(\".\").forEach(r=>{e<<=8,e+=parseInt(r)}),e>>>0};g.fromLong=function(t){return`${t>>>24}.${t>>16&255}.${t>>8&255}.${t&255}`}});var Un=he((ie,In)=>{var An=typeof self<\"u\"?self:ie,nt=function(){function t(){this.fetch=!1,this.DOMException=An.DOMException}return t.prototype=An,new t}();(function(t){var e=function(r){var n={searchParams:\"URLSearchParams\"in t,iterable:\"Symbol\"in t&&\"iterator\"in Symbol,blob:\"FileReader\"in t&&\"Blob\"in t&&function(){try{return new Blob,!0}catch{return!1}}(),formData:\"FormData\"in t,arrayBuffer:\"ArrayBuffer\"in t};function i(c){return c&&DataView.prototype.isPrototypeOf(c)}if(n.arrayBuffer)var o=[\"[object Int8Array]\",\"[object Uint8Array]\",\"[object Uint8ClampedArray]\",\"[object Int16Array]\",\"[object Uint16Array]\",\"[object Int32Array]\",\"[object Uint32Array]\",\"[object Float32Array]\",\"[object Float64Array]\"],s=ArrayBuffer.isView||function(c){return c&&o.indexOf(Object.prototype.toString.call(c))>-1};function a(c){if(typeof c!=\"string\"&&(c=String(c)),/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(c))throw new TypeError(\"Invalid character in header field name\");return c.toLowerCase()}function d(c){return typeof c!=\"string\"&&(c=String(c)),c}function w(c){var p={next:function(){var E=c.shift();return{done:E===void 0,value:E}}};return n.iterable&&(p[Symbol.iterator]=function(){return p}),p}function l(c){this.map={},c instanceof l?c.forEach(function(p,E){this.append(E,p)},this):Array.isArray(c)?c.forEach(function(p){this.append(p[0],p[1])},this):c&&Object.getOwnPropertyNames(c).forEach(function(p){this.append(p,c[p])},this)}l.prototype.append=function(c,p){c=a(c),p=d(p);var E=this.map[c];this.map[c]=E?E+\", \"+p:p},l.prototype.delete=function(c){delete this.map[a(c)]},l.prototype.get=function(c){return c=a(c),this.has(c)?this.map[c]:null},l.prototype.has=function(c){return this.map.hasOwnProperty(a(c))},l.prototype.set=function(c,p){this.map[a(c)]=d(p)},l.prototype.forEach=function(c,p){for(var E in this.map)this.map.hasOwnProperty(E)&&c.call(p,this.map[E],E,this)},l.prototype.keys=function(){var c=[];return this.forEach(function(p,E){c.push(E)}),w(c)},l.prototype.values=function(){var c=[];return this.forEach(function(p){c.push(p)}),w(c)},l.prototype.entries=function(){var c=[];return this.forEach(function(p,E){c.push([E,p])}),w(c)},n.iterable&&(l.prototype[Symbol.iterator]=l.prototype.entries);function m(c){if(c.bodyUsed)return Promise.reject(new TypeError(\"Already read\"));c.bodyUsed=!0}function N(c){return new Promise(function(p,E){c.onload=function(){p(c.result)},c.onerror=function(){E(c.error)}})}function R(c){var p=new FileReader,E=N(p);return p.readAsArrayBuffer(c),E}function B(c){var p=new FileReader,E=N(p);return p.readAsText(c),E}function S(c){for(var p=new Uint8Array(c),E=new Array(p.length),v=0;v<p.length;v++)E[v]=String.fromCharCode(p[v]);return E.join(\"\")}function J(c){if(c.slice)return c.slice(0);var p=new Uint8Array(c.byteLength);return p.set(new Uint8Array(c)),p.buffer}function $(){return this.bodyUsed=!1,this._initBody=function(c){this._bodyInit=c,c?typeof c==\"string\"?this._bodyText=c:n.blob&&Blob.prototype.isPrototypeOf(c)?this._bodyBlob=c:n.formData&&FormData.prototype.isPrototypeOf(c)?this._bodyFormData=c:n.searchParams&&URLSearchParams.prototype.isPrototypeOf(c)?this._bodyText=c.toString():n.arrayBuffer&&n.blob&&i(c)?(this._bodyArrayBuffer=J(c.buffer),this._bodyInit=new Blob([this._bodyArrayBuffer])):n.arrayBuffer&&(ArrayBuffer.prototype.isPrototypeOf(c)||s(c))?this._bodyArrayBuffer=J(c):this._bodyText=c=Object.prototype.toString.call(c):this._bodyText=\"\",this.headers.get(\"content-type\")||(typeof c==\"string\"?this.headers.set(\"content-type\",\"text/plain;charset=UTF-8\"):this._bodyBlob&&this._bodyBlob.type?this.headers.set(\"content-type\",this._bodyBlob.type):n.searchParams&&URLSearchParams.prototype.isPrototypeOf(c)&&this.headers.set(\"content-type\",\"application/x-www-form-urlencoded;charset=UTF-8\"))},n.blob&&(this.blob=function(){var c=m(this);if(c)return c;if(this._bodyBlob)return Promise.resolve(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(new Blob([this._bodyArrayBuffer]));if(this._bodyFormData)throw new Error(\"could not read FormData body as blob\");return Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){return this._bodyArrayBuffer?m(this)||Promise.resolve(this._bodyArrayBuffer):this.blob().then(R)}),this.text=function(){var c=m(this);if(c)return c;if(this._bodyBlob)return B(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(S(this._bodyArrayBuffer));if(this._bodyFormData)throw new Error(\"could not read FormData body as text\");return Promise.resolve(this._bodyText)},n.formData&&(this.formData=function(){return this.text().then(V)}),this.json=function(){return this.text().then(JSON.parse)},this}var z=[\"DELETE\",\"GET\",\"HEAD\",\"OPTIONS\",\"POST\",\"PUT\"];function j(c){var p=c.toUpperCase();return z.indexOf(p)>-1?p:c}function T(c,p){p=p||{};var E=p.body;if(c instanceof T){if(c.bodyUsed)throw new TypeError(\"Already read\");this.url=c.url,this.credentials=c.credentials,p.headers||(this.headers=new l(c.headers)),this.method=c.method,this.mode=c.mode,this.signal=c.signal,!E&&c._bodyInit!=null&&(E=c._bodyInit,c.bodyUsed=!0)}else this.url=String(c);if(this.credentials=p.credentials||this.credentials||\"same-origin\",(p.headers||!this.headers)&&(this.headers=new l(p.headers)),this.method=j(p.method||this.method||\"GET\"),this.mode=p.mode||this.mode||null,this.signal=p.signal||this.signal,this.referrer=null,(this.method===\"GET\"||this.method===\"HEAD\")&&E)throw new TypeError(\"Body not allowed for GET or HEAD requests\");this._initBody(E)}T.prototype.clone=function(){return new T(this,{body:this._bodyInit})};function V(c){var p=new FormData;return c.trim().split(\"&\").forEach(function(E){if(E){var v=E.split(\"=\"),k=v.shift().replace(/\\+/g,\" \"),A=v.join(\"=\").replace(/\\+/g,\" \");p.append(decodeURIComponent(k),decodeURIComponent(A))}}),p}function Y(c){var p=new l,E=c.replace(/\\r?\\n[\\t ]+/g,\" \");return E.split(/\\r?\\n/).forEach(function(v){var k=v.split(\":\"),A=k.shift().trim();if(A){var Le=k.join(\":\").trim();p.append(A,Le)}}),p}$.call(T.prototype);function I(c,p){p||(p={}),this.type=\"default\",this.status=p.status===void 0?200:p.status,this.ok=this.status>=200&&this.status<300,this.statusText=\"statusText\"in p?p.statusText:\"OK\",this.headers=new l(p.headers),this.url=p.url||\"\",this._initBody(c)}$.call(I.prototype),I.prototype.clone=function(){return new I(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new l(this.headers),url:this.url})},I.error=function(){var c=new I(null,{status:0,statusText:\"\"});return c.type=\"error\",c};var W=[301,302,303,307,308];I.redirect=function(c,p){if(W.indexOf(p)===-1)throw new RangeError(\"Invalid status code\");return new I(null,{status:p,headers:{location:c}})},r.DOMException=t.DOMException;try{new r.DOMException}catch{r.DOMException=function(p,E){this.message=p,this.name=E;var v=Error(p);this.stack=v.stack},r.DOMException.prototype=Object.create(Error.prototype),r.DOMException.prototype.constructor=r.DOMException}function oe(c,p){return new Promise(function(E,v){var k=new T(c,p);if(k.signal&&k.signal.aborted)return v(new r.DOMException(\"Aborted\",\"AbortError\"));var A=new XMLHttpRequest;function Le(){A.abort()}A.onload=function(){var _e={status:A.status,statusText:A.statusText,headers:Y(A.getAllResponseHeaders()||\"\")};_e.url=\"responseURL\"in A?A.responseURL:_e.headers.get(\"X-Request-URL\");var it=\"response\"in A?A.response:A.responseText;E(new I(it,_e))},A.onerror=function(){v(new TypeError(\"Network request failed\"))},A.ontimeout=function(){v(new TypeError(\"Network request failed\"))},A.onabort=function(){v(new r.DOMException(\"Aborted\",\"AbortError\"))},A.open(k.method,k.url,!0),k.credentials===\"include\"?A.withCredentials=!0:k.credentials===\"omit\"&&(A.withCredentials=!1),\"responseType\"in A&&n.blob&&(A.responseType=\"blob\"),k.headers.forEach(function(_e,it){A.setRequestHeader(it,_e)}),k.signal&&(k.signal.addEventListener(\"abort\",Le),A.onreadystatechange=function(){A.readyState===4&&k.signal.removeEventListener(\"abort\",Le)}),A.send(typeof k._bodyInit>\"u\"?null:k._bodyInit)})}return oe.polyfill=!0,t.fetch||(t.fetch=oe,t.Headers=l,t.Request=T,t.Response=I),r.Headers=l,r.Request=T,r.Response=I,r.fetch=oe,Object.defineProperty(r,\"__esModule\",{value:!0}),r}({})})(nt);nt.fetch.ponyfill=!0;delete nt.fetch.polyfill;var Se=nt;ie=Se.fetch;ie.default=Se.fetch;ie.fetch=Se.fetch;ie.Headers=Se.Headers;ie.Request=Se.Request;ie.Response=Se.Response;In.exports=ie});var Dn=(t,e,r,n)=>{if(r===\"length\"||r===\"prototype\"||r===\"arguments\"||r===\"caller\")return;let i=Object.getOwnPropertyDescriptor(t,r),o=Object.getOwnPropertyDescriptor(e,r);!Mn(i,o)&&n||Object.defineProperty(t,r,o)},Mn=function(t,e){return t===void 0||t.configurable||t.writable===e.writable&&t.enumerable===e.enumerable&&t.configurable===e.configurable&&(t.writable||t.value===e.value)},Pn=(t,e)=>{let r=Object.getPrototypeOf(e);r!==Object.getPrototypeOf(t)&&Object.setPrototypeOf(t,r)},Ln=(t,e)=>`/* Wrapped ${t}*/\n${e}`,zn=Object.getOwnPropertyDescriptor(Function.prototype,\"toString\"),jn=Object.getOwnPropertyDescriptor(Function.prototype.toString,\"name\"),Vn=(t,e,r)=>{let n=r===\"\"?\"\":`with ${r.trim()}() `,i=Ln.bind(null,n,e.toString());Object.defineProperty(i,\"name\",jn),Object.defineProperty(t,\"toString\",{...zn,value:i})};function ot(t,e,{ignoreNonConfigurable:r=!1}={}){let{name:n}=t;for(let i of Reflect.ownKeys(e))Dn(t,e,i,r);return Pn(t,e),Vn(t,e,n),t}var qn=new WeakMap;function st(t,{cacheKey:e=([n])=>n,cache:r=new Map}={}){let n=new Map,i=function(...o){let s=e(o);if(n.has(s))return n.get(s);let a=(async()=>{try{if(r&&await r.has(s))return await r.get(s);let w=await t.apply(this,o);try{return w}finally{r&&await r.set(s,w)}}finally{n.delete(s)}})();return n.set(s,a),a};return ot(i,t,{ignoreNonConfigurable:!0}),qn.set(i,r),i}var Sn=Rt(ir(),1);var Ti=[\"string\",\"number\",\"bigint\",\"symbol\"],Si=[\"Function\",\"Generator\",\"AsyncGenerator\",\"GeneratorFunction\",\"AsyncGeneratorFunction\",\"AsyncFunction\",\"Observable\",\"Array\",\"Buffer\",\"Object\",\"RegExp\",\"Date\",\"Error\",\"Map\",\"Set\",\"WeakMap\",\"WeakSet\",\"ArrayBuffer\",\"SharedArrayBuffer\",\"DataView\",\"Promise\",\"URL\",\"HTMLElement\",\"Int8Array\",\"Uint8Array\",\"Uint8ClampedArray\",\"Int16Array\",\"Uint16Array\",\"Int32Array\",\"Uint32Array\",\"Float32Array\",\"Float64Array\",\"BigInt64Array\",\"BigUint64Array\"];function or(t){if(t===null)return\"null\";if(t===void 0)return\"undefined\";if(t===!0||t===!1)return\"boolean\";let e=typeof t;if(Ti.includes(e))return e;if(e===\"function\")return\"Function\";if(Array.isArray(t))return\"Array\";if(_i(t))return\"Buffer\";let r=Fi(t);return r||\"Object\"}function _i(t){return t&&t.constructor&&t.constructor.isBuffer&&t.constructor.isBuffer.call(null,t)}function Fi(t){let e=Object.prototype.toString.call(t).slice(8,-1);if(Si.includes(e))return e}var f=class{constructor(e,r,n){this.major=e,this.majorEncoded=e<<5,this.name=r,this.terminal=n}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}};f.uint=new f(0,\"uint\",!0);f.negint=new f(1,\"negint\",!0);f.bytes=new f(2,\"bytes\",!0);f.string=new f(3,\"string\",!0);f.array=new f(4,\"array\",!1);f.map=new f(5,\"map\",!1);f.tag=new f(6,\"tag\",!1);f.float=new f(7,\"float\",!0);f.false=new f(7,\"false\",!0);f.true=new f(7,\"true\",!0);f.null=new f(7,\"null\",!0);f.undefined=new f(7,\"undefined\",!0);f.break=new f(7,\"break\",!0);var y=class{constructor(e,r,n){this.type=e,this.value=r,this.encodedLength=n,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}};var me=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&typeof globalThis.Buffer.isBuffer==\"function\",ki=new TextDecoder,Ci=new TextEncoder;function Ge(t){return me&&globalThis.Buffer.isBuffer(t)}function ar(t){return t instanceof Uint8Array?Ge(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t:Uint8Array.from(t)}var fr=me?(t,e,r)=>r-e>64?globalThis.Buffer.from(t.subarray(e,r)).toString(\"utf8\"):cr(t,e,r):(t,e,r)=>r-e>64?ki.decode(t.subarray(e,r)):cr(t,e,r),lr=me?t=>t.length>64?globalThis.Buffer.from(t):sr(t):t=>t.length>64?Ci.encode(t):sr(t);var ge=me?(t,e,r)=>Ge(t)?new Uint8Array(t.subarray(e,r)):t.slice(e,r):(t,e,r)=>t.slice(e,r),hr=me?(t,e)=>(t=t.map(r=>r instanceof Uint8Array?r:globalThis.Buffer.from(r)),ar(globalThis.Buffer.concat(t,e))):(t,e)=>{let r=new Uint8Array(e),n=0;for(let i of t)n+i.length>r.length&&(i=i.subarray(0,r.length-n)),r.set(i,n),n+=i.length;return r},dr=me?t=>globalThis.Buffer.allocUnsafe(t):t=>new Uint8Array(t);function pr(t,e){if(Ge(t)&&Ge(e))return t.compare(e);for(let r=0;r<t.length;r++)if(t[r]!==e[r])return t[r]<e[r]?-1:1;return 0}function sr(t,e=1/0){let r,n=t.length,i=null,o=[];for(let s=0;s<n;++s){if(r=t.charCodeAt(s),r>55295&&r<57344){if(!i){if(r>56319){(e-=3)>-1&&o.push(239,191,189);continue}else if(s+1===n){(e-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(e-=3)>-1&&o.push(239,191,189),i=r;continue}r=(i-55296<<10|r-56320)+65536}else i&&(e-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((e-=1)<0)break;o.push(r)}else if(r<2048){if((e-=2)<0)break;o.push(r>>6|192,r&63|128)}else if(r<65536){if((e-=3)<0)break;o.push(r>>12|224,r>>6&63|128,r&63|128)}else if(r<1114112){if((e-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,r&63|128)}else throw new Error(\"Invalid code point\")}return o}function cr(t,e,r){let n=[];for(;e<r;){let i=t[e],o=null,s=i>239?4:i>223?3:i>191?2:1;if(e+s<=r){let a,d,w,l;switch(s){case 1:i<128&&(o=i);break;case 2:a=t[e+1],(a&192)===128&&(l=(i&31)<<6|a&63,l>127&&(o=l));break;case 3:a=t[e+1],d=t[e+2],(a&192)===128&&(d&192)===128&&(l=(i&15)<<12|(a&63)<<6|d&63,l>2047&&(l<55296||l>57343)&&(o=l));break;case 4:a=t[e+1],d=t[e+2],w=t[e+3],(a&192)===128&&(d&192)===128&&(w&192)===128&&(l=(i&15)<<18|(a&63)<<12|(d&63)<<6|w&63,l>65535&&l<1114112&&(o=l))}}o===null?(o=65533,s=1):o>65535&&(o-=65536,n.push(o>>>10&1023|55296),o=56320|o&1023),n.push(o),e+=s}return vi(n)}var ur=4096;function vi(t){let e=t.length;if(e<=ur)return String.fromCharCode.apply(String,t);let r=\"\",n=0;for(;n<e;)r+=String.fromCharCode.apply(String,t.slice(n,n+=ur));return r}var Ni=256,He=class{constructor(e=Ni){this.chunkSize=e,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),this._initReuseChunk!==null&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(e){let r=this.chunks[this.chunks.length-1];if(this.cursor+e.length<=this.maxCursor+1){let i=r.length-(this.maxCursor-this.cursor)-1;r.set(e,i)}else{if(r){let i=r.length-(this.maxCursor-this.cursor)-1;i<r.length&&(this.chunks[this.chunks.length-1]=r.subarray(0,i),this.maxCursor=this.cursor-1)}e.length<64&&e.length<this.chunkSize?(r=dr(this.chunkSize),this.chunks.push(r),this.maxCursor+=r.length,this._initReuseChunk===null&&(this._initReuseChunk=r),r.set(e,0)):(this.chunks.push(e),this.maxCursor+=e.length)}this.cursor+=e.length}toBytes(e=!1){let r;if(this.chunks.length===1){let n=this.chunks[0];e&&this.cursor>n.length/2?(r=this.cursor===n.length?n:n.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):r=ge(n,0,this.cursor)}else r=hr(this.chunks,this.cursor);return e&&this.reset(),r}};var x=\"CBOR decode error:\",mt=\"CBOR encode error:\",Ce=[];Ce[23]=1;Ce[24]=2;Ce[25]=3;Ce[26]=5;Ce[27]=9;function re(t,e,r){if(t.length-e<r)throw new Error(`${x} not enough data for type`)}var F=[24,256,65536,4294967296,BigInt(\"18446744073709551616\")];function D(t,e,r){re(t,e,1);let n=t[e];if(r.strict===!0&&n<F[0])throw new Error(`${x} integer encoded in more bytes than necessary (strict decode)`);return n}function M(t,e,r){re(t,e,2);let n=t[e]<<8|t[e+1];if(r.strict===!0&&n<F[1])throw new Error(`${x} integer encoded in more bytes than necessary (strict decode)`);return n}function P(t,e,r){re(t,e,4);let n=t[e]*16777216+(t[e+1]<<16)+(t[e+2]<<8)+t[e+3];if(r.strict===!0&&n<F[2])throw new Error(`${x} integer encoded in more bytes than necessary (strict decode)`);return n}function L(t,e,r){re(t,e,8);let n=t[e]*16777216+(t[e+1]<<16)+(t[e+2]<<8)+t[e+3],i=t[e+4]*16777216+(t[e+5]<<16)+(t[e+6]<<8)+t[e+7],o=(BigInt(n)<<BigInt(32))+BigInt(i);if(r.strict===!0&&o<F[3])throw new Error(`${x} integer encoded in more bytes than necessary (strict decode)`);if(o<=Number.MAX_SAFE_INTEGER)return Number(o);if(r.allowBigInt===!0)return o;throw new Error(`${x} integers outside of the safe integer range are not supported`)}function yr(t,e,r,n){return new y(f.uint,D(t,e+1,n),2)}function wr(t,e,r,n){return new y(f.uint,M(t,e+1,n),3)}function mr(t,e,r,n){return new y(f.uint,P(t,e+1,n),5)}function gr(t,e,r,n){return new y(f.uint,L(t,e+1,n),9)}function G(t,e){return C(t,0,e.value)}function C(t,e,r){if(r<F[0]){let n=Number(r);t.push([e|n])}else if(r<F[1]){let n=Number(r);t.push([e|24,n])}else if(r<F[2]){let n=Number(r);t.push([e|25,n>>>8,n&255])}else if(r<F[3]){let n=Number(r);t.push([e|26,n>>>24&255,n>>>16&255,n>>>8&255,n&255])}else{let n=BigInt(r);if(n<F[4]){let i=[e|27,0,0,0,0,0,0,0],o=Number(n&BigInt(4294967295)),s=Number(n>>BigInt(32)&BigInt(4294967295));i[8]=o&255,o=o>>8,i[7]=o&255,o=o>>8,i[6]=o&255,o=o>>8,i[5]=o&255,i[4]=s&255,s=s>>8,i[3]=s&255,s=s>>8,i[2]=s&255,s=s>>8,i[1]=s&255,t.push(i)}else throw new Error(`${x} encountered BigInt larger than allowable range`)}}G.encodedSize=function(e){return C.encodedSize(e.value)};C.encodedSize=function(e){return e<F[0]?1:e<F[1]?2:e<F[2]?3:e<F[3]?5:9};G.compareTokens=function(e,r){return e.value<r.value?-1:e.value>r.value?1:0};function xr(t,e,r,n){return new y(f.negint,-1-D(t,e+1,n),2)}function Er(t,e,r,n){return new y(f.negint,-1-M(t,e+1,n),3)}function br(t,e,r,n){return new y(f.negint,-1-P(t,e+1,n),5)}var gt=BigInt(-1),Br=BigInt(1);function Ar(t,e,r,n){let i=L(t,e+1,n);if(typeof i!=\"bigint\"){let o=-1-i;if(o>=Number.MIN_SAFE_INTEGER)return new y(f.negint,o,9)}if(n.allowBigInt!==!0)throw new Error(`${x} integers outside of the safe integer range are not supported`);return new y(f.negint,gt-BigInt(i),9)}function We(t,e){let r=e.value,n=typeof r==\"bigint\"?r*gt-Br:r*-1-1;C(t,e.type.majorEncoded,n)}We.encodedSize=function(e){let r=e.value,n=typeof r==\"bigint\"?r*gt-Br:r*-1-1;return n<F[0]?1:n<F[1]?2:n<F[2]?3:n<F[3]?5:9};We.compareTokens=function(e,r){return e.value<r.value?1:e.value>r.value?-1:0};function ve(t,e,r,n){re(t,e,r+n);let i=ge(t,e+r,e+r+n);return new y(f.bytes,i,r+n)}function Ir(t,e,r,n){return ve(t,e,1,r)}function Ur(t,e,r,n){return ve(t,e,2,D(t,e+1,n))}function Tr(t,e,r,n){return ve(t,e,3,M(t,e+1,n))}function Sr(t,e,r,n){return ve(t,e,5,P(t,e+1,n))}function _r(t,e,r,n){let i=L(t,e+1,n);if(typeof i==\"bigint\")throw new Error(`${x} 64-bit integer bytes lengths not supported`);return ve(t,e,9,i)}function Xe(t){return t.encodedBytes===void 0&&(t.encodedBytes=t.type===f.string?lr(t.value):t.value),t.encodedBytes}function xe(t,e){let r=Xe(e);C(t,e.type.majorEncoded,r.length),t.push(r)}xe.encodedSize=function(e){let r=Xe(e);return C.encodedSize(r.length)+r.length};xe.compareTokens=function(e,r){return $i(Xe(e),Xe(r))};function $i(t,e){return t.length<e.length?-1:t.length>e.length?1:pr(t,e)}function Ne(t,e,r,n,i){let o=r+n;re(t,e,o);let s=new y(f.string,fr(t,e+r,e+o),o);return i.retainStringBytes===!0&&(s.byteValue=ge(t,e+r,e+o)),s}function Fr(t,e,r,n){return Ne(t,e,1,r,n)}function kr(t,e,r,n){return Ne(t,e,2,D(t,e+1,n),n)}function Cr(t,e,r,n){return Ne(t,e,3,M(t,e+1,n),n)}function vr(t,e,r,n){return Ne(t,e,5,P(t,e+1,n),n)}function Nr(t,e,r,n){let i=L(t,e+1,n);if(typeof i==\"bigint\")throw new Error(`${x} 64-bit integer string lengths not supported`);return Ne(t,e,9,i,n)}var Rr=xe;function Ee(t,e,r,n){return new y(f.array,n,r)}function $r(t,e,r,n){return Ee(t,e,1,r)}function Or(t,e,r,n){return Ee(t,e,2,D(t,e+1,n))}function Dr(t,e,r,n){return Ee(t,e,3,M(t,e+1,n))}function Mr(t,e,r,n){return Ee(t,e,5,P(t,e+1,n))}function Pr(t,e,r,n){let i=L(t,e+1,n);if(typeof i==\"bigint\")throw new Error(`${x} 64-bit integer array lengths not supported`);return Ee(t,e,9,i)}function Lr(t,e,r,n){if(n.allowIndefinite===!1)throw new Error(`${x} indefinite length items not allowed`);return Ee(t,e,1,1/0)}function Ke(t,e){C(t,f.array.majorEncoded,e.value)}Ke.compareTokens=G.compareTokens;Ke.encodedSize=function(e){return C.encodedSize(e.value)};function be(t,e,r,n){return new y(f.map,n,r)}function zr(t,e,r,n){return be(t,e,1,r)}function jr(t,e,r,n){return be(t,e,2,D(t,e+1,n))}function Vr(t,e,r,n){return be(t,e,3,M(t,e+1,n))}function qr(t,e,r,n){return be(t,e,5,P(t,e+1,n))}function Gr(t,e,r,n){let i=L(t,e+1,n);if(typeof i==\"bigint\")throw new Error(`${x} 64-bit integer map lengths not supported`);return be(t,e,9,i)}function Hr(t,e,r,n){if(n.allowIndefinite===!1)throw new Error(`${x} indefinite length items not allowed`);return be(t,e,1,1/0)}function Je(t,e){C(t,f.map.majorEncoded,e.value)}Je.compareTokens=G.compareTokens;Je.encodedSize=function(e){return C.encodedSize(e.value)};function Wr(t,e,r,n){return new y(f.tag,r,1)}function Xr(t,e,r,n){return new y(f.tag,D(t,e+1,n),2)}function Kr(t,e,r,n){return new y(f.tag,M(t,e+1,n),3)}function Jr(t,e,r,n){return new y(f.tag,P(t,e+1,n),5)}function Yr(t,e,r,n){return new y(f.tag,L(t,e+1,n),9)}function Ye(t,e){C(t,f.tag.majorEncoded,e.value)}Ye.compareTokens=G.compareTokens;Ye.encodedSize=function(e){return C.encodedSize(e.value)};var zi=20,ji=21,Vi=22,qi=23;function Qr(t,e,r,n){if(n.allowUndefined===!1)throw new Error(`${x} undefined values are not supported`);return n.coerceUndefinedToNull===!0?new y(f.null,null,1):new y(f.undefined,void 0,1)}function Zr(t,e,r,n){if(n.allowIndefinite===!1)throw new Error(`${x} indefinite length items not allowed`);return new y(f.break,void 0,1)}function xt(t,e,r){if(r){if(r.allowNaN===!1&&Number.isNaN(t))throw new Error(`${x} NaN values are not supported`);if(r.allowInfinity===!1&&(t===1/0||t===-1/0))throw new Error(`${x} Infinity values are not supported`)}return new y(f.float,t,e)}function en(t,e,r,n){return xt(Et(t,e+1),3,n)}function tn(t,e,r,n){return xt(bt(t,e+1),5,n)}function rn(t,e,r,n){return xt(cn(t,e+1),9,n)}function Qe(t,e,r){let n=e.value;if(n===!1)t.push([f.float.majorEncoded|zi]);else if(n===!0)t.push([f.float.majorEncoded|ji]);else if(n===null)t.push([f.float.majorEncoded|Vi]);else if(n===void 0)t.push([f.float.majorEncoded|qi]);else{let i,o=!1;(!r||r.float64!==!0)&&(on(n),i=Et(X,1),n===i||Number.isNaN(n)?(X[0]=249,t.push(X.slice(0,3)),o=!0):(sn(n),i=bt(X,1),n===i&&(X[0]=250,t.push(X.slice(0,5)),o=!0))),o||(Gi(n),i=cn(X,1),X[0]=251,t.push(X.slice(0,9)))}}Qe.encodedSize=function(e,r){let n=e.value;if(n===!1||n===!0||n===null||n===void 0)return 1;if(!r||r.float64!==!0){on(n);let i=Et(X,1);if(n===i||Number.isNaN(n))return 3;if(sn(n),i=bt(X,1),n===i)return 5}return 9};var nn=new ArrayBuffer(9),H=new DataView(nn,1),X=new Uint8Array(nn,0);function on(t){if(t===1/0)H.setUint16(0,31744,!1);else if(t===-1/0)H.setUint16(0,64512,!1);else if(Number.isNaN(t))H.setUint16(0,32256,!1);else{H.setFloat32(0,t);let e=H.getUint32(0),r=(e&2139095040)>>23,n=e&8388607;if(r===255)H.setUint16(0,31744,!1);else if(r===0)H.setUint16(0,(t&2147483648)>>16|n>>13,!1);else{let i=r-127;i<-24?H.setUint16(0,0):i<-14?H.setUint16(0,(e&2147483648)>>16|1<<24+i,!1):H.setUint16(0,(e&2147483648)>>16|i+15<<10|n>>13,!1)}}}function Et(t,e){if(t.length-e<2)throw new Error(`${x} not enough data for float16`);let r=(t[e]<<8)+t[e+1];if(r===31744)return 1/0;if(r===64512)return-1/0;if(r===32256)return NaN;let n=r>>10&31,i=r&1023,o;return n===0?o=i*2**-24:n!==31?o=(i+1024)*2**(n-25):o=i===0?1/0:NaN,r&32768?-o:o}function sn(t){H.setFloat32(0,t,!1)}function bt(t,e){if(t.length-e<4)throw new Error(`${x} not enough data for float32`);let r=(t.byteOffset||0)+e;return new DataView(t.buffer,r,4).getFloat32(0,!1)}function Gi(t){H.setFloat64(0,t,!1)}function cn(t,e){if(t.length-e<8)throw new Error(`${x} not enough data for float64`);let r=(t.byteOffset||0)+e;return new DataView(t.buffer,r,8).getFloat64(0,!1)}Qe.compareTokens=G.compareTokens;function b(t,e,r){throw new Error(`${x} encountered invalid minor (${r}) for major ${t[e]>>>5}`)}function Ze(t){return()=>{throw new Error(`${x} ${t}`)}}var h=[];for(let t=0;t<=23;t++)h[t]=b;h[24]=yr;h[25]=wr;h[26]=mr;h[27]=gr;h[28]=b;h[29]=b;h[30]=b;h[31]=b;for(let t=32;t<=55;t++)h[t]=b;h[56]=xr;h[57]=Er;h[58]=br;h[59]=Ar;h[60]=b;h[61]=b;h[62]=b;h[63]=b;for(let t=64;t<=87;t++)h[t]=Ir;h[88]=Ur;h[89]=Tr;h[90]=Sr;h[91]=_r;h[92]=b;h[93]=b;h[94]=b;h[95]=Ze(\"indefinite length bytes/strings are not supported\");for(let t=96;t<=119;t++)h[t]=Fr;h[120]=kr;h[121]=Cr;h[122]=vr;h[123]=Nr;h[124]=b;h[125]=b;h[126]=b;h[127]=Ze(\"indefinite length bytes/strings are not supported\");for(let t=128;t<=151;t++)h[t]=$r;h[152]=Or;h[153]=Dr;h[154]=Mr;h[155]=Pr;h[156]=b;h[157]=b;h[158]=b;h[159]=Lr;for(let t=160;t<=183;t++)h[t]=zr;h[184]=jr;h[185]=Vr;h[186]=qr;h[187]=Gr;h[188]=b;h[189]=b;h[190]=b;h[191]=Hr;for(let t=192;t<=215;t++)h[t]=Wr;h[216]=Xr;h[217]=Kr;h[218]=Jr;h[219]=Yr;h[220]=b;h[221]=b;h[222]=b;h[223]=b;for(let t=224;t<=243;t++)h[t]=Ze(\"simple values are not supported\");h[244]=b;h[245]=b;h[246]=b;h[247]=Qr;h[248]=Ze(\"simple values are not supported\");h[249]=en;h[250]=tn;h[251]=rn;h[252]=b;h[253]=b;h[254]=b;h[255]=Zr;var K=[];for(let t=0;t<24;t++)K[t]=new y(f.uint,t,1);for(let t=-1;t>=-24;t--)K[31-t]=new y(f.negint,t,1);K[64]=new y(f.bytes,new Uint8Array(0),1);K[96]=new y(f.string,\"\",1);K[128]=new y(f.array,0,1);K[160]=new y(f.map,0,1);K[244]=new y(f.false,!1,1);K[245]=new y(f.true,!0,1);K[246]=new y(f.null,null,1);function Wi(){let t=[];return t[f.uint.major]=G,t[f.negint.major]=We,t[f.bytes.major]=xe,t[f.string.major]=Rr,t[f.array.major]=Ke,t[f.map.major]=Je,t[f.tag.major]=Ye,t[f.float.major]=Qe,t}var qs=Wi(),Gs=new He,Be=class{constructor(e,r){this.obj=e,this.parent=r}includes(e){let r=this;do if(r.obj===e)return!0;while(r=r.parent);return!1}static createCheck(e,r){if(e&&e.includes(r))throw new Error(`${mt} object contains circular references`);return new Be(r,e)}},ce={null:new y(f.null,null),undefined:new y(f.undefined,void 0),true:new y(f.true,!0),false:new y(f.false,!1),emptyArray:new y(f.array,0),emptyMap:new y(f.map,0)},ue={number(t,e,r,n){return!Number.isInteger(t)||!Number.isSafeInteger(t)?new y(f.float,t):t>=0?new y(f.uint,t):new y(f.negint,t)},bigint(t,e,r,n){return t>=BigInt(0)?new y(f.uint,t):new y(f.negint,t)},Uint8Array(t,e,r,n){return new y(f.bytes,t)},string(t,e,r,n){return new y(f.string,t)},boolean(t,e,r,n){return t?ce.true:ce.false},null(t,e,r,n){return ce.null},undefined(t,e,r,n){return ce.undefined},ArrayBuffer(t,e,r,n){return new y(f.bytes,new Uint8Array(t))},DataView(t,e,r,n){return new y(f.bytes,new Uint8Array(t.buffer,t.byteOffset,t.byteLength))},Array(t,e,r,n){if(!t.length)return r.addBreakTokens===!0?[ce.emptyArray,new y(f.break)]:ce.emptyArray;n=Be.createCheck(n,t);let i=[],o=0;for(let s of t)i[o++]=Bt(s,r,n);return r.addBreakTokens?[new y(f.array,t.length),i,new y(f.break)]:[new y(f.array,t.length),i]},Object(t,e,r,n){let i=e!==\"Object\",o=i?t.keys():Object.keys(t),s=i?t.size:o.length;if(!s)return r.addBreakTokens===!0?[ce.emptyMap,new y(f.break)]:ce.emptyMap;n=Be.createCheck(n,t);let a=[],d=0;for(let w of o)a[d++]=[Bt(w,r,n),Bt(i?t.get(w):t[w],r,n)];return Xi(a,r),r.addBreakTokens?[new y(f.map,s),a,new y(f.break)]:[new y(f.map,s),a]}};ue.Map=ue.Object;ue.Buffer=ue.Uint8Array;for(let t of\"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64\".split(\" \"))ue[`${t}Array`]=ue.DataView;function Bt(t,e={},r){let n=or(t),i=e&&e.typeEncoders&&e.typeEncoders[n]||ue[n];if(typeof i==\"function\"){let s=i(t,n,e,r);if(s!=null)return s}let o=ue[n];if(!o)throw new Error(`${mt} unsupported type: ${n}`);return o(t,n,e,r)}function Xi(t,e){e.mapSorter&&t.sort(e.mapSorter)}var Ki={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0},At=class{constructor(e,r={}){this.pos=0,this.data=e,this.options=r}done(){return this.pos>=this.data.length}next(){let e=this.data[this.pos],r=K[e];if(r===void 0){let n=h[e];if(!n)throw new Error(`${x} no decoder for major type ${e>>>5} (byte 0x${e.toString(16).padStart(2,\"0\")})`);let i=e&31;r=n(this.data,this.pos,i,this.options)}return this.pos+=r.encodedLength,r}},Re=Symbol.for(\"DONE\"),et=Symbol.for(\"BREAK\");function Ji(t,e,r){let n=[];for(let i=0;i<t.value;i++){let o=$e(e,r);if(o===et){if(t.value===1/0)break;throw new Error(`${x} got unexpected break to lengthed array`)}if(o===Re)throw new Error(`${x} found array but not enough entries (got ${i}, expected ${t.value})`);n[i]=o}return n}function Yi(t,e,r){let n=r.useMaps===!0,i=n?void 0:{},o=n?new Map:void 0;for(let s=0;s<t.value;s++){let a=$e(e,r);if(a===et){if(t.value===1/0)break;throw new Error(`${x} got unexpected break to lengthed map`)}if(a===Re)throw new Error(`${x} found map but not enough entries (got ${s} [no key], expected ${t.value})`);if(n!==!0&&typeof a!=\"string\")throw new Error(`${x} non-string keys not supported (got ${typeof a})`);let d=$e(e,r);if(d===Re)throw new Error(`${x} found map but not enough entries (got ${s} [no value], expected ${t.value})`);n?o.set(a,d):i[a]=d}return n?o:i}function $e(t,e){if(t.done())return Re;let r=t.next();if(r.type===f.break)return et;if(r.type.terminal)return r.value;if(r.type===f.array)return Ji(r,t,e);if(r.type===f.map)return Yi(r,t,e);if(r.type===f.tag){if(e.tags&&typeof e.tags[r.value]==\"function\"){let n=$e(t,e);return e.tags[r.value](n)}throw new Error(`${x} tag not supported (${r.value})`)}throw new Error(\"unsupported\")}function It(t,e){if(!(t instanceof Uint8Array))throw new Error(`${x} data to decode must be a Uint8Array`);e=Object.assign({},Ki,e);let r=e.tokenizer||new At(t,e),n=$e(r,e);if(n===Re)throw new Error(`${x} did not find any content to decode`);if(n===et)throw new Error(`${x} got unexpected break`);if(!r.done())throw new Error(`${x} too many terminals, data makes no sense`);return n}var eo=fn,un=128,to=127,ro=~to,no=Math.pow(2,31);function fn(t,e,r){e=e||[],r=r||0;for(var n=r;t>=no;)e[r++]=t&255|un,t/=128;for(;t&ro;)e[r++]=t&255|un,t>>>=7;return e[r]=t|0,fn.bytes=r-n+1,e}var io=Ut,oo=128,an=127;function Ut(t,n){var r=0,n=n||0,i=0,o=n,s,a=t.length;do{if(o>=a)throw Ut.bytes=0,new RangeError(\"Could not decode varint\");s=t[o++],r+=i<28?(s&an)<<i:(s&an)*Math.pow(2,i),i+=7}while(s>=oo);return Ut.bytes=o-n,r}var so=Math.pow(2,7),co=Math.pow(2,14),uo=Math.pow(2,21),ao=Math.pow(2,28),fo=Math.pow(2,35),lo=Math.pow(2,42),ho=Math.pow(2,49),po=Math.pow(2,56),yo=Math.pow(2,63),wo=function(t){return t<so?1:t<co?2:t<uo?3:t<ao?4:t<fo?5:t<lo?6:t<ho?7:t<po?8:t<yo?9:10},mo={encode:eo,decode:io,encodingLength:wo},go=mo,Oe=go;var De=(t,e=0)=>[Oe.decode(t,e),Oe.decode.bytes],Ae=(t,e,r=0)=>(Oe.encode(t,e,r),e),Ie=t=>Oe.encodingLength(t);var rc=new Uint8Array(0);var hn=(t,e)=>{if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0},Ue=t=>{if(t instanceof Uint8Array&&t.constructor.name===\"Uint8Array\")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error(\"Unknown type, must be binary type\")};var dn=(t,e)=>{let r=e.byteLength,n=Ie(t),i=n+Ie(r),o=new Uint8Array(i+r);return Ae(t,o,0),Ae(r,o,n),o.set(e,i),new Te(t,r,e,o)},pn=t=>{let e=Ue(t),[r,n]=De(e),[i,o]=De(e.subarray(n)),s=e.subarray(n+o);if(s.byteLength!==i)throw new Error(\"Incorrect length\");return new Te(r,i,s,e)},yn=(t,e)=>t===e?!0:t.code===e.code&&t.size===e.size&&hn(t.bytes,e.bytes),Te=class{constructor(e,r,n,i){this.code=e,this.size=r,this.digest=n,this.bytes=i}};function Eo(t,e){if(t.length>=255)throw new TypeError(\"Alphabet too long\");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var i=0;i<t.length;i++){var o=t.charAt(i),s=o.charCodeAt(0);if(r[s]!==255)throw new TypeError(o+\" is ambiguous\");r[s]=i}var a=t.length,d=t.charAt(0),w=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function m(B){if(B instanceof Uint8Array||(ArrayBuffer.isView(B)?B=new Uint8Array(B.buffer,B.byteOffset,B.byteLength):Array.isArray(B)&&(B=Uint8Array.from(B))),!(B instanceof Uint8Array))throw new TypeError(\"Expected Uint8Array\");if(B.length===0)return\"\";for(var S=0,J=0,$=0,z=B.length;$!==z&&B[$]===0;)$++,S++;for(var j=(z-$)*l+1>>>0,T=new Uint8Array(j);$!==z;){for(var V=B[$],Y=0,I=j-1;(V!==0||Y<J)&&I!==-1;I--,Y++)V+=256*T[I]>>>0,T[I]=V%a>>>0,V=V/a>>>0;if(V!==0)throw new Error(\"Non-zero carry\");J=Y,$++}for(var W=j-J;W!==j&&T[W]===0;)W++;for(var oe=d.repeat(S);W<j;++W)oe+=t.charAt(T[W]);return oe}function N(B){if(typeof B!=\"string\")throw new TypeError(\"Expected String\");if(B.length===0)return new Uint8Array;var S=0;if(B[S]!==\" \"){for(var J=0,$=0;B[S]===d;)J++,S++;for(var z=(B.length-S)*w+1>>>0,j=new Uint8Array(z);B[S];){var T=r[B.charCodeAt(S)];if(T===255)return;for(var V=0,Y=z-1;(T!==0||V<$)&&Y!==-1;Y--,V++)T+=a*j[Y]>>>0,j[Y]=T%256>>>0,T=T/256>>>0;if(T!==0)throw new Error(\"Non-zero carry\");$=V,S++}if(B[S]!==\" \"){for(var I=z-$;I!==z&&j[I]===0;)I++;for(var W=new Uint8Array(J+(z-I)),oe=J;I!==z;)W[oe++]=j[I++];return W}}}function R(B){var S=N(B);if(S)return S;throw new Error(`Non-${e} character`)}return{encode:m,decodeUnsafe:N,decode:R}}var bo=Eo,Bo=bo,wn=Bo;var Tt=class{constructor(e,r,n){this.name=e,this.prefix=r,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error(\"Unknown type, must be binary type\")}},St=class{constructor(e,r,n){if(this.name=e,this.prefix=r,r.codePointAt(0)===void 0)throw new Error(\"Invalid prefix character\");this.prefixCodePoint=r.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e==\"string\"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error(\"Can only multibase decode strings\")}or(e){return mn(this,e)}},_t=class{constructor(e){this.decoders=e}or(e){return mn(this,e)}decode(e){let r=e[0],n=this.decoders[r];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}},mn=(t,e)=>new _t({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}}),Ft=class{constructor(e,r,n,i){this.name=e,this.prefix=r,this.baseEncode=n,this.baseDecode=i,this.encoder=new Tt(e,r,n),this.decoder=new St(e,r,i)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}},gn=({name:t,prefix:e,encode:r,decode:n})=>new Ft(t,e,r,n),kt=({prefix:t,name:e,alphabet:r})=>{let{encode:n,decode:i}=wn(r,e);return gn({prefix:t,name:e,encode:n,decode:o=>Ue(i(o))})},Ao=(t,e,r,n)=>{let i={};for(let l=0;l<e.length;++l)i[e[l]]=l;let o=t.length;for(;t[o-1]===\"=\";)--o;let s=new Uint8Array(o*r/8|0),a=0,d=0,w=0;for(let l=0;l<o;++l){let m=i[t[l]];if(m===void 0)throw new SyntaxError(`Non-${n} character`);d=d<<r|m,a+=r,a>=8&&(a-=8,s[w++]=255&d>>a)}if(a>=r||255&d<<8-a)throw new SyntaxError(\"Unexpected end of data\");return s},Io=(t,e,r)=>{let n=e[e.length-1]===\"=\",i=(1<<r)-1,o=\"\",s=0,a=0;for(let d=0;d<t.length;++d)for(a=a<<8|t[d],s+=8;s>r;)s-=r,o+=e[i&a>>s];if(s&&(o+=e[i&a<<r-s]),n)for(;o.length*r&7;)o+=\"=\";return o},ee=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>gn({prefix:e,name:t,encode(i){return Io(i,n,r)},decode(i){return Ao(i,n,r,t)}});var ne=kt({name:\"base58btc\",prefix:\"z\",alphabet:\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"}),fc=kt({name:\"base58flickr\",prefix:\"Z\",alphabet:\"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"});var Me=ee({prefix:\"b\",name:\"base32\",alphabet:\"abcdefghijklmnopqrstuvwxyz234567\",bitsPerChar:5}),dc=ee({prefix:\"B\",name:\"base32upper\",alphabet:\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",bitsPerChar:5}),pc=ee({prefix:\"c\",name:\"base32pad\",alphabet:\"abcdefghijklmnopqrstuvwxyz234567=\",bitsPerChar:5}),yc=ee({prefix:\"C\",name:\"base32padupper\",alphabet:\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\",bitsPerChar:5}),wc=ee({prefix:\"v\",name:\"base32hex\",alphabet:\"0123456789abcdefghijklmnopqrstuv\",bitsPerChar:5}),mc=ee({prefix:\"V\",name:\"base32hexupper\",alphabet:\"0123456789ABCDEFGHIJKLMNOPQRSTUV\",bitsPerChar:5}),gc=ee({prefix:\"t\",name:\"base32hexpad\",alphabet:\"0123456789abcdefghijklmnopqrstuv=\",bitsPerChar:5}),xc=ee({prefix:\"T\",name:\"base32hexpadupper\",alphabet:\"0123456789ABCDEFGHIJKLMNOPQRSTUV=\",bitsPerChar:5}),Ec=ee({prefix:\"h\",name:\"base32z\",alphabet:\"ybndrfg8ejkmcpqxot1uwisza345h769\",bitsPerChar:5});var U=class{constructor(e,r,n,i){this.code=r,this.version=e,this.multihash=n,this.bytes=i,this.byteOffset=i.byteOffset,this.byteLength=i.byteLength,this.asCID=this,this._baseCache=new Map,Object.defineProperties(this,{byteOffset:rt,byteLength:rt,code:tt,version:tt,multihash:tt,bytes:tt,_baseCache:rt,asCID:rt})}toV0(){switch(this.version){case 0:return this;default:{let{code:e,multihash:r}=this;if(e!==Pe)throw new Error(\"Cannot convert a non dag-pb CID to CIDv0\");if(r.code!==_o)throw new Error(\"Cannot convert non sha2-256 multihash CID to CIDv0\");return U.createV0(r)}}}toV1(){switch(this.version){case 0:{let{code:e,digest:r}=this.multihash,n=dn(e,r);return U.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}equals(e){return e&&this.code===e.code&&this.version===e.version&&yn(this.multihash,e.multihash)}toString(e){let{bytes:r,version:n,_baseCache:i}=this;switch(n){case 0:return To(r,i,e||ne.encoder);default:return So(r,i,e||Me.encoder)}}toJSON(){return{code:this.code,version:this.version,hash:this.multihash.bytes}}get[Symbol.toStringTag](){return\"CID\"}[Symbol.for(\"nodejs.util.inspect.custom\")](){return\"CID(\"+this.toString()+\")\"}static isCID(e){return ko(/^0\\.0/,Co),!!(e&&(e[En]||e.asCID===e))}get toBaseEncodedString(){throw new Error(\"Deprecated, use .toString()\")}get codec(){throw new Error('\"codec\" property is deprecated, use integer \"code\" property instead')}get buffer(){throw new Error(\"Deprecated .buffer property, use .bytes to get Uint8Array instead\")}get multibaseName(){throw new Error('\"multibaseName\" property is deprecated')}get prefix(){throw new Error('\"prefix\" property is deprecated')}static asCID(e){if(e instanceof U)return e;if(e!=null&&e.asCID===e){let{version:r,code:n,multihash:i,bytes:o}=e;return new U(r,n,i,o||xn(r,n,i.bytes))}else if(e!=null&&e[En]===!0){let{version:r,multihash:n,code:i}=e,o=pn(n);return U.create(r,i,o)}else return null}static create(e,r,n){if(typeof r!=\"number\")throw new Error(\"String codecs are no longer supported\");switch(e){case 0:{if(r!==Pe)throw new Error(`Version 0 CID must use dag-pb (code: ${Pe}) block encoding`);return new U(e,r,n,n.bytes)}case 1:{let i=xn(e,r,n.bytes);return new U(e,r,n,i)}default:throw new Error(\"Invalid version\")}}static createV0(e){return U.create(0,Pe,e)}static createV1(e,r){return U.create(1,e,r)}static decode(e){let[r,n]=U.decodeFirst(e);if(n.length)throw new Error(\"Incorrect length\");return r}static decodeFirst(e){let r=U.inspectBytes(e),n=r.size-r.multihashSize,i=Ue(e.subarray(n,n+r.multihashSize));if(i.byteLength!==r.multihashSize)throw new Error(\"Incorrect length\");let o=i.subarray(r.multihashSize-r.digestSize),s=new Te(r.multihashCode,r.digestSize,o,i);return[r.version===0?U.createV0(s):U.createV1(r.codec,s),e.subarray(r.size)]}static inspectBytes(e){let r=0,n=()=>{let[m,N]=De(e.subarray(r));return r+=N,m},i=n(),o=Pe;if(i===18?(i=0,r=0):i===1&&(o=n()),i!==0&&i!==1)throw new RangeError(`Invalid CID version ${i}`);let s=r,a=n(),d=n(),w=r+d,l=w-s;return{version:i,codec:o,multihashCode:a,digestSize:d,multihashSize:l,size:w}}static parse(e,r){let[n,i]=Uo(e,r),o=U.decode(i);return o._baseCache.set(n,e),o}},Uo=(t,e)=>{switch(t[0]){case\"Q\":{let r=e||ne;return[ne.prefix,r.decode(`${ne.prefix}${t}`)]}case ne.prefix:{let r=e||ne;return[ne.prefix,r.decode(t)]}case Me.prefix:{let r=e||Me;return[Me.prefix,r.decode(t)]}default:{if(e==null)throw Error(\"To parse non base32 or base58btc encoded CID multibase decoder must be provided\");return[t[0],e.decode(t)]}}},To=(t,e,r)=>{let{prefix:n}=r;if(n!==ne.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);let i=e.get(n);if(i==null){let o=r.encode(t).slice(1);return e.set(n,o),o}else return i},So=(t,e,r)=>{let{prefix:n}=r,i=e.get(n);if(i==null){let o=r.encode(t);return e.set(n,o),o}else return i},Pe=112,_o=18,xn=(t,e,r)=>{let n=Ie(t),i=n+Ie(e),o=new Uint8Array(i+r.byteLength);return Ae(t,o,0),Ae(e,o,n),o.set(r,i),o},En=Symbol.for(\"@ipld/js-cid/CID\"),tt={writable:!1,configurable:!1,enumerable:!0},rt={writable:!1,enumerable:!1,configurable:!1},Fo=\"0.0.0-dev\",ko=(t,e)=>{if(t.test(Fo))console.warn(e);else throw new Error(e)},Co=`CID.isCID(v) is deprecated and will be removed in the next major release.\nFollowing code pattern:\n\nif (CID.isCID(value)) {\n  doSomethingWithCID(value)\n}\n\nIs replaced with:\n\nconst cid = CID.asCID(value)\nif (cid) {\n  // Make sure to use cid instead of value\n  doSomethingWithCID(cid)\n}\n`;var vo=42;function No(t){if(t[0]!==0)throw new Error(\"Invalid CID for CBOR tag 42; expected leading 0x00\");return U.decode(t.subarray(1))}var bn={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};bn.tags[vo]=No;var Bn=t=>It(t,bn);var _n=Rt(Un(),1);var Ro=\"Earth\";function Tn(t){return{country_name:t[0],country_code:t[1],region_code:t[2],city:t[3],postal_code:t[4],latitude:t[5],longitude:t[6],planet:Ro}}var Oo=U.parse(\"bafyreihnpl7ami7esahkfdnemm6idx4r2n6u3apmtcrxlqwuapgjsciihy\"),Do=[\"https://ipfs.io\",\"https://dweb.link\"];async function Mo(t,e){if(typeof t==\"function\")return t(e);if(typeof t?.block?.get==\"function\")return t.block.get(e);let r=Array.isArray(t)?t:[t];for(let n of r){let i=new URL(n);i.pathname=`/ipfs/${e.toString()}`,i.search=\"?format=raw\";try{let o=await(0,_n.default)(i,{headers:{Accept:\"application/vnd.ipld.raw\"},cache:\"force-cache\"});if(!o.ok)throw o;return new Uint8Array(await o.arrayBuffer())}catch(o){throw new Error(`unable to fetch raw block for CID ${e}`,{cause:o})}}}async function Fn(t,e,r=1){try{let n=await Mo(t,e);return{obj:await Bn(n),block:n}}catch(n){if(r<3)return await Fn(t,e,r+1);throw n}}async function Po(t,e,r){let n,i;try{({obj:n,block:i}=await Fn(t,e))}catch(s){throw(process?.env?.DEBUG||process?.env?.TEST)&&console.error(i?`[ipfs-geoip] failed to parse DAG-CBOR behind CID '${e}'`:`[ipfs-geoip] failed to get raw block for CID '${e}'`,s),s}let o=0;if(\"data\"in n){if(\"data\"in n){for(;n.data[o]&&n.data[o].min<=r;)o++;let s=n.data[o-1];if(!s)throw new Error(\"Failed to lookup leaf node\");if(!s.data)throw new Error(\"Unmapped range\");return Tn(s.data)}}else{for(;n.mins[o]&&n.mins[o]<=r;)o++;let s=n.links[o-1];if(!s)throw new Error(\"Failed to lookup node\");let a=Lo(s);if(!a)throw new Error(\"Failed to lookup node\");return kn(t,a,r)}}var kn=st(Po,{cachePromiseRejection:!1,cacheKey:t=>{let[,e,r]=t;return`${e}.${r}`}});function Ct(t=Do,e){return kn(t,Oo,Sn.default.toLong(e))}function Lo(t){return t?U.asCID(t):null}function zo(t){let e=t.split(\".\");return e[0]===\"10\"||e[0]===\"127\"||e[0]===\"192\"&&e[1]===\"168\"||e[0]===\"172\"&&Number(e[1])>=16&&Number(e[1])<=31}async function vt(t,e){if(e.length===0)throw new Error(\"lookup requires a multiaddr array with length > 0\");typeof e==\"string\"&&(e=[e]);let r=e[0].split(\"/\"),n=r[2];if(zo(n)||r[1]===\"ip6\"){if(e.slice(1).length>0)return vt(t,e.slice(1));throw new Error(\"Unmapped range\")}let i=await Ct(t,n);if(!i.country_name&&e.length>1)return vt(t,e.slice(1));let o=[];return i.planet&&o.push(i.planet),i.country_name&&o.unshift(i.country_name),i.region_code&&o.unshift(i.region_code),i.city&&o.unshift(i.city),i.formatted=o.join(\", \"),i}export{Ct as lookup,vt as lookupPretty};\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n","import { createAsyncResourceBundle, createSelector } from 'redux-bundler'\nimport { getConfiguredCache } from 'money-clip'\nimport { lookup } from 'ipfs-geoip'\nimport PQueue from 'p-queue'\nimport HLRU from 'hashlru'\nimport Multiaddr from 'multiaddr'\nimport ms from 'milliseconds'\nimport ip from 'ip'\nimport memoize from 'p-memoize'\nimport pkgJson from '../../package.json'\n\nconst { dependencies } = pkgJson\n\n// After this time interval, we re-check the locations for each peer\n// once again through PeerLocationResolver.\nconst UPDATE_EVERY = ms.seconds(1)\n\n// We reuse cached geoip lookups as long geoipVersion is the same.\nconst geoipVersion = dependencies['ipfs-geoip']\n\n// Depends on ipfsBundle, peersBundle\nfunction createPeersLocations (opts) {\n  opts = opts || {}\n  // Max number of locations to retrieve concurrently.\n  // HTTP API are throttled to max 4-6 at a time by the browser itself.\n  opts.concurrency = opts.concurrency || 4\n  // Cache options\n  opts.cache = opts.cache || {}\n\n  const peerLocResolver = new PeerLocationResolver(opts)\n\n  const bundle = createAsyncResourceBundle({\n    name: 'peerLocations',\n    actionBaseType: 'PEER_LOCATIONS',\n    getPromise: ({ store }) => peerLocResolver.findLocations(\n      store.selectAvailableGatewayUrl(), store.selectPeers()),\n    staleAfter: UPDATE_EVERY,\n    retryAfter: UPDATE_EVERY,\n    persist: false,\n    checkIfOnline: false\n  })\n\n  bundle.reactPeerLocationsFetch = createSelector(\n    'selectRouteInfo',\n    'selectPeerLocationsShouldUpdate',\n    'selectIpfsConnected',\n    (routeInfo, shouldUpdate, ipfsConnected) => {\n      if (routeInfo.url === '/peers' && shouldUpdate && ipfsConnected) {\n        return { actionCreator: 'doFetchPeerLocations' }\n      }\n    }\n  )\n\n  bundle.selectPeerLocationsForSwarm = createSelector(\n    'selectPeers',\n    'selectPeerLocations',\n    'selectBootstrapPeers',\n    'selectIdentity', // ipfs.id info for local node, used for detecting local peers\n    (peers, locations = {}, bootstrapPeers, identity) => peers && peers.map(peer => {\n      const peerId = peer.peer\n      const locationObj = locations ? locations[peerId] : null\n      const location = toLocationString(locationObj)\n      const flagCode = locationObj && locationObj.country_code\n      const coordinates = locationObj && [\n        locationObj.longitude,\n        locationObj.latitude\n      ]\n      const connection = parseConnection(peer.addr)\n      const address = peer.addr.toString()\n      const latency = parseLatency(peer.latency)\n      const direction = peer.direction\n      const { isPrivate, isNearby } = isPrivateAndNearby(peer.addr, identity)\n\n      const protocols = (Array.isArray(peer.streams)\n        ? Array.from(new Set(peer.streams\n          .map(s => s.Protocol)\n          .map(p => (!p?.trim() ? '[unnamed]' : p)) // mark weird 'empty' protocols\n        )).sort()\n        : []).join(', ')\n\n      return {\n        peerId,\n        location,\n        flagCode,\n        coordinates,\n        connection,\n        address,\n        protocols,\n        direction,\n        latency,\n        isPrivate,\n        isNearby\n      }\n    })\n  )\n\n  const COORDINATES_RADIUS = 4\n\n  bundle.selectPeersCoordinates = createSelector(\n    'selectPeerLocationsForSwarm',\n    peers => {\n      if (!peers) return []\n\n      return peers.reduce((previous, { peerId, coordinates }) => {\n        if (!coordinates) return previous\n\n        let hasFoundACloseCoordinate = false\n\n        const previousCoordinates = previous.map(prev => {\n          if (!prev || hasFoundACloseCoordinate) return prev\n\n          const [x, y] = prev.coordinates\n          const [currentX, currentY] = coordinates\n\n          const isCloseInXAxis = x - COORDINATES_RADIUS <= currentX && x + COORDINATES_RADIUS >= currentX\n          const isCloseInYAxis = y - COORDINATES_RADIUS <= currentY && y + COORDINATES_RADIUS >= currentY\n\n          if (isCloseInXAxis && isCloseInYAxis) {\n            prev.peerIds.push(peerId)\n            hasFoundACloseCoordinate = true\n          }\n\n          return prev\n        })\n\n        if (hasFoundACloseCoordinate) {\n          return previousCoordinates\n        }\n\n        return [...previousCoordinates, { peerIds: [peerId], coordinates }]\n      }, [])\n    }\n  )\n\n  return bundle\n}\n\nconst isNonHomeIPv4 = t => t[0] === 4 && t[1] !== '127.0.0.1'\n\nconst toLocationString = loc => {\n  if (!loc) return null\n  const { country_name: country, city } = loc\n  return city && country ? `${country}, ${city}` : country\n}\n\nconst parseConnection = (multiaddr) => {\n  return multiaddr.protoNames().join(' • ')\n}\n\nconst parseLatency = (latency) => {\n  if (latency === 'n/a') return\n\n  let value = parseInt(latency)\n  const unit = /(s|ms)/.exec(latency)[0]\n\n  value = unit === 's' ? value * 1000 : value\n\n  return value\n}\n\nconst getPublicIP = memoize((identity) => {\n  if (!identity) return\n\n  for (const maddr of identity.addresses) {\n    try {\n      const addr = Multiaddr(maddr).nodeAddress()\n\n      if ((ip.isV4Format(addr.address) || ip.isV6Format(addr.address)) && !ip.isPrivate(addr.address)) {\n        return addr.address\n      }\n    } catch (_) {}\n  }\n})\n\nconst isPrivateAndNearby = (maddr, identity) => {\n  const publicIP = getPublicIP(identity)\n  let isPrivate = false\n  let isNearby = false\n  let addr\n\n  try {\n    addr = maddr.nodeAddress()\n  } catch (_) {\n    // Might explode if maddr does not have an IP or cannot be converted\n    // to a node address. This might happen if it's a relay. We do not print\n    // or handle the error, otherwise we would get perhaps thousands of logs.\n    return { isPrivate, isNearby }\n  }\n\n  // At this point, addr.address and publicIP must be valid IP addresses. Hence,\n  // none of the calls bellow for ip library should fail.\n  isPrivate = ip.isPrivate(addr.address)\n\n  if (publicIP) {\n    if (ip.isV4Format(addr.address)) {\n      isNearby = ip.cidrSubnet(`${publicIP}/24`).contains(addr.address)\n    } else if (ip.isV6Format(addr.address)) {\n      isNearby = ip.cidrSubnet(`${publicIP}/48`).contains(addr.address) &&\n        !ip.cidrSubnet('fc00::/8').contains(addr.address)\n      // peerIP6 ∉ fc00::/8 to fix case of cjdns where IPs are not spatial allocated.\n    }\n  }\n\n  return { isPrivate, isNearby }\n}\n\nclass PeerLocationResolver {\n  constructor (opts) {\n    this.geoipCache = getConfiguredCache({\n      name: 'geoipCache',\n      version: geoipVersion,\n      maxAge: ms.weeks(1),\n      ...opts.cache\n    })\n\n    this.failedAddrs = HLRU(500)\n\n    this.queue = new PQueue({\n      concurrency: opts.concurrency,\n      autoStart: true\n    })\n\n    this.geoipLookupPromises = new Map()\n\n    this.pass = 0\n  }\n\n  async findLocations (gatewayUrls, peers) {\n    const res = {}\n\n    for (const p of this.optimizedPeerSet(peers)) {\n      const peerId = p.peer\n\n      const ipv4Tuple = p.addr.stringTuples().find(isNonHomeIPv4)\n      if (!ipv4Tuple) {\n        continue\n      }\n\n      const ipv4Addr = ipv4Tuple[1]\n      if (this.failedAddrs.has(ipv4Addr)) {\n        continue\n      }\n\n      // maybe we have it cached by ipv4 address already, check that.\n      const location = await this.geoipCache.get(ipv4Addr)\n      if (location) {\n        res[peerId] = location\n        continue\n      }\n\n      // no ip address cached. are we looking it up already?\n      if (this.geoipLookupPromises.has(ipv4Addr)) {\n        continue\n      }\n\n      this.geoipLookupPromises.set(ipv4Addr, this.queue.add(async () => {\n        try {\n          const data = await lookup(gatewayUrls, ipv4Addr)\n          await this.geoipCache.set(ipv4Addr, data)\n        } catch (e) {\n          // mark this one as failed so we don't retry again\n          this.failedAddrs.set(ipv4Addr, true)\n        } finally {\n          this.geoipLookupPromises.delete(ipv4Addr)\n        }\n      }))\n    }\n\n    return res\n  }\n\n  optimizedPeerSet (peers) {\n    if (this.pass < 3) {\n      // use a copy of peers sorted by latency so we can resolve closest ones first\n      // (https://github.com/ipfs-shipyard/ipfs-webui/issues/1273)\n      const ms = x => (parseLatency(x.latency) || 9999)\n      const sortedPeersByLatency = peers.concat().sort((a, b) => ms(a) - ms(b))\n      // take the closest subset, increase sample size each time\n      // this ensures initial map updates are fast even with thousands of peers\n      this.pass = this.pass + 1\n\n      switch (this.pass - 1) {\n        case 0:\n          return sortedPeersByLatency.slice(0, 10)\n        case 1:\n          return sortedPeersByLatency.slice(0, 100)\n        default:\n          return sortedPeersByLatency.slice(0, 200)\n      }\n    }\n    return peers\n  }\n}\nexport default createPeersLocations\n","// @ts-check\nimport { pinningServiceTemplates } from '../constants/pinning'\nimport memoize from 'p-memoize'\nimport CID from 'cids'\nimport all from 'it-all'\n\nimport { readSetting, writeSetting } from './local-storage'\n\n// This bundle leverages createCacheBundle and persistActions for\n// the persistence layer that keeps pins in IndexDB store\n// to ensure they are around across restarts/reloads/refactors/releases.\n\nconst CID_PIN_CHECK_BATCH_SIZE = 10 // Pinata returns error when >10\n\nconst PIN_CHECK_INTERVAL = 30000\n\n// id = `${serviceName}:${cid}`\nconst cacheId2Cid = (id) => id.split(':').at(-1)\nconst cacheId2ServiceName = (id) => id.split(':').at(0)\n\nconst uniq = (arr) => [...new Set(arr)]\nconst notIn = (...arrays) => p => arrays.every(array => !array.some(a => a === p))\n\nconst parseService = async (service, remoteServiceTemplates, ipfs) => {\n  const template = remoteServiceTemplates.find(t => service.endpoint.toString() === t.apiEndpoint.toString())\n  const icon = template?.icon\n  const visitServiceUrl = template?.visitServiceUrl\n  const parsedService = { ...service, name: service.service, icon, visitServiceUrl }\n\n  if (service?.stat?.status === 'invalid') {\n    return { ...parsedService, numberOfPins: -1, online: false }\n  }\n\n  const numberOfPins = service.stat?.pinCount?.pinned\n  const online = typeof numberOfPins === 'number'\n  const autoUpload = online ? await mfsPolicyEnableFlag(service.service, ipfs) : undefined\n\n  return { ...parsedService, numberOfPins, online, autoUpload }\n}\n\nconst mfsPolicyEnableFlag = memoize(async (serviceName, ipfs) => {\n  try {\n    return await ipfs.config.get(`Pinning.RemoteServices.${serviceName}.Policies.MFS.Enable`)\n  } catch (e) {\n    if (e.message?.includes('key has no attribute')) {\n      try { // retry with notation from https://github.com/ipfs/kubo/pull/8096\n        return await ipfs.config.get(`Pinning.RemoteServices[\"${serviceName}\"].Policies.MFS.Enable`)\n      } catch (_) {}\n    }\n    console.error(`unexpected config.get error for \"${serviceName}\": ${e.message}`)\n  }\n  return false\n}, { maxAge: 3000 })\n\nconst uniqueCidBatches = (arrayOfCids, size) => {\n  const array = [...new Set(arrayOfCids)] // deduplicate CIDs\n  const result = []\n  for (let i = 0; i < array.length; i += size) {\n    const chunk = array.slice(i, i + size)\n    result.push(chunk)\n  }\n  return result\n}\n\nconst remotePinLs = (ipfs, params) => {\n  const backoffs = readSetting('remotesServicesBackoffs') || {}\n  const { service } = params\n\n  const { lastTry, tryAfter } = backoffs[service] || { lastTry: 0, tryAfter: PIN_CHECK_INTERVAL }\n  if (lastTry + tryAfter > new Date().getTime()) {\n    throw new Error('still within back-off period')\n  }\n\n  try {\n    return ipfs.pin.remote.ls(params)\n  } catch (e) {\n    if (e.toString().includes('429 Too Many Requests')) {\n      backoffs[service] = {\n        lastTry: new Date().getTime(),\n        tryAfter: tryAfter * 3\n      }\n      writeSetting('remotesServicesBackoffs', backoffs)\n    }\n\n    throw e\n  }\n}\n\nconst resumePendingPins = (store) => {\n  const interval = setInterval(() => {\n    const isReady = store.selectIpfsReady()\n    if (isReady) {\n      clearTimeout(interval)\n      const pendingPins = store.selectPendingPins()\n\n      pendingPins.forEach(pin => {\n        const [service, cid] = pin.split(':')\n        store.doSetPinning({ cid: new CID(cid) }, [service], false)\n      })\n    }\n  }, 1000)\n}\n\nconst intervalFetchPins = (store) => {\n  setInterval(() => {\n    const pins = [\n      ...store.selectPendingPins(),\n      ...store.selectFailedPins()\n    ].map(serviceCid => ({ cid: serviceCid.split(':')[1] }))\n    store.doFetchRemotePins(pins, true)\n  }, PIN_CHECK_INTERVAL)\n}\n\nconst pinningBundle = {\n  name: 'pinning',\n  persistActions: ['UPDATE_REMOTE_PINS', 'DISMISS_REMOTE_PINS', 'CANCEL_PENDING_PINS'],\n  init: store => {\n    resumePendingPins(store)\n    intervalFetchPins(store)\n  },\n  reducer: (state, action) => {\n    if (action.type === 'UPDATE_REMOTE_PINS') {\n      const { adds = [], removals = [], pending = [], failed = [] } = action.payload\n\n      const remotePins = uniq([...state.remotePins, ...adds].filter(notIn(removals, pending, failed)))\n      const notRemotePins = uniq([...state.notRemotePins, ...removals].filter(notIn(adds, pending, failed)))\n      const pendingPins = uniq([...state.pendingPins, ...pending].filter(notIn(adds, removals, failed)))\n      const failedPins = uniq([...state.failedPins, ...failed].filter(notIn(adds, removals, pending)))\n      const completedPins = uniq([...state.completedPins, ...adds].filter(p => state.pendingPins.some(a => a === p)))\n\n      return { ...state, remotePins, notRemotePins, pendingPins, failedPins, completedPins }\n    }\n    if (action.type === 'DISMISS_REMOTE_PINS') {\n      const { failed = [], completed = [] } = action.payload\n\n      const failedPins = state.failedPins.filter(notIn(failed))\n      const completedPins = state.completedPins.filter(notIn(completed))\n\n      return { ...state, failedPins, completedPins }\n    }\n    if (action.type === 'SET_LOCAL_PINS_STATS') {\n      const { localPinsSize, localNumberOfPins } = action.payload\n      return { ...state, localNumberOfPins, localPinsSize }\n    }\n    if (action.type === 'SET_REMOTE_PINNING_SERVICES') {\n      const oldServices = state.pinningServices\n      const newServices = action.payload\n      // Skip update when list length did not change and new one has no stats\n      if (oldServices?.length === newServices?.length) {\n        const withPinStats = s => (s && typeof s.numberOfPins !== 'undefined')\n        const oldStats = oldServices.some(withPinStats)\n        const newStats = newServices.some(withPinStats)\n        if (oldStats && !newStats) return state\n      }\n      return { ...state, pinningServices: newServices }\n    }\n    if (action.type === 'SET_REMOTE_PINNING_SERVICES_AVAILABLE') {\n      return { ...state, arePinningServicesSupported: action.payload }\n    }\n\n    /**\n     * state defaults should be set here.\n     *\n     * @see https://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers#rules-of-reducers\n     */\n    return {\n      ...state,\n      pinningServices: state?.pinningServices ?? [],\n      remotePins: state?.remotePins ?? [],\n      pendingPins: state?.pendingPins ?? [],\n      failedPins: state?.failedPins ?? [],\n      completedPins: state?.completedPins ?? [],\n      notRemotePins: state?.notRemotePins ?? [],\n      localPinsSize: state?.localPinsSize ?? 0,\n      localNumberOfPins: state?.localNumberOfPins ?? 0,\n      arePinningServicesSupported: state?.arePinningServicesSupported ?? false\n    }\n  },\n\n  doFetchRemotePins: (files, skipCache = false) => async ({ dispatch, store, getIpfs }) => {\n    const pinningServices = store.selectPinningServices()\n    if (!pinningServices?.length) return\n    const ipfs = getIpfs()\n    if (!ipfs || store?.ipfs?.ipfs?.ready || !ipfs.pin.remote) return\n\n    const allCids = files ? files.map(f => f.cid.toString()) : []\n\n    // Reuse known state for some CIDs to avoid unnecessary requests\n    const remotePins = store.selectRemotePins()\n    const notRemotePins = store.selectNotRemotePins()\n\n    // Check remaining CID status in chunks based on API limitation seen in real world\n    const cids = uniqueCidBatches(allCids, CID_PIN_CHECK_BATCH_SIZE)\n\n    const adds = []\n    const removals = []\n    const failed = []\n    const pending = []\n\n    await Promise.allSettled(pinningServices.map(async service => {\n      try {\n        // skip CIDs that we know the state of at this service\n        const skipCids = skipCache\n          ? new Set()\n          : new Set(\n            [...remotePins, ...notRemotePins]\n              .filter(id => id.startsWith(service.name))\n              .map(cacheId2Cid)\n          )\n        for (const cidChunk of cids) {\n          const cidsToCheck = cidChunk.filter(cid => !skipCids.has(cid.toString()))\n          if (!cidsToCheck.length) continue // skip if no new cids to check\n          const notPins = new Set(cidsToCheck.map(cid => cid.toString()))\n          try {\n            const pins = remotePinLs(ipfs, { service: service.name, cid: cidsToCheck.map(cid => new CID(cid)), status: ['queued', 'pinning', 'pinned', 'failed'] })\n            for await (const pin of pins) {\n              const pinCid = pin.cid.toString()\n              notPins.delete(pinCid)\n\n              if (pin.status === 'queued' || pin.status === 'pinning') {\n                pending.push(`${service.name}:${pinCid}`)\n              } else if (pin.status === 'failed') {\n                failed.push(`${service.name}:${pinCid}`)\n              } else {\n                adds.push(`${service.name}:${pinCid}`)\n              }\n            }\n            // store 'not pinned remotely on this service' to avoid future checks\n          } catch (e) {\n            console.error(`Error: pin.remote.ls service=${service.name} cid=${cidsToCheck}: ${e.toString()}`)\n          }\n          // cache remaining ones as not pinned\n          for (const notPinCid of notPins) {\n            removals.push(`${service.name}:${notPinCid}`)\n          }\n        }\n      } catch (e) {\n        // ignore service and network errors for now\n        // and continue checking remaining ones\n        console.error('unexpected error during doFetchRemotePins', e)\n      }\n    }))\n    dispatch({ type: 'UPDATE_REMOTE_PINS', payload: { adds, removals, pending, failed } })\n  },\n\n  selectRemotePins: (state) => state.pinning.remotePins || [],\n  selectNotRemotePins: (state) => state.pinning.notRemotePins || [],\n  selectPendingPins: (state) => state.pinning.pendingPins || [],\n  selectFailedPins: (state) => state.pinning.failedPins || [],\n  selectCompletedPins: (state) => state.pinning.completedPins || [],\n\n  selectLocalPinsSize: (state) => state.pinning.localPinsSize,\n  selectLocalNumberOfPins: (state) => state.pinning.localNumberOfPins,\n\n  doSelectRemotePinsForFile: (file) => ({ store }) => {\n    const pinningServicesNames = store.selectPinningServices().map(remote => remote.name)\n    const remoteAndPendingPins = uniq([...store.selectPendingPins(), ...store.selectRemotePins()])\n    const remoteAndPendingPinsForFile = remoteAndPendingPins.filter(pin => cacheId2Cid(pin) === file.cid.toString())\n    const servicesBeingUsed = remoteAndPendingPinsForFile.map(pin => cacheId2ServiceName(pin)).filter(name => pinningServicesNames.includes(name))\n    return servicesBeingUsed\n  },\n\n  // gets the amount of local pins\n  doFetchLocalPinsStats: () => async ({ getIpfs, dispatch }) => {\n    const ipfs = getIpfs()\n    if (!ipfs) return null\n\n    const localPins = await all(ipfs.pin.ls({ type: 'recursive' }))\n    const localPinsSize = -1 // TODO: right now calculating size of all pins is too expensive (requires ipfs.files.stat per CID)\n    const localNumberOfPins = localPins.length\n\n    dispatch({ type: 'SET_LOCAL_PINS_STATS', payload: { localPinsSize, localNumberOfPins } })\n  },\n\n  // list of services without online check (reads list from config, should be instant)\n  doFetchPinningServices: () => async ({ getIpfs, store, dispatch }) => {\n    const ipfs = getIpfs()\n    if (!ipfs || store?.ipfs?.ipfs?.ready || !ipfs.pin.remote) return null\n\n    const isPinRemotePresent = (await ipfs.commands()).Subcommands.find(c => c.Name === 'pin').Subcommands.some(c => c.Name === 'remote')\n    dispatch({ type: 'SET_REMOTE_PINNING_SERVICES_AVAILABLE', payload: isPinRemotePresent })\n    if (!isPinRemotePresent) return null\n\n    const remoteServiceTemplates = store.selectRemoteServiceTemplates()\n    const offlineListOfServices = await ipfs.pin.remote.service.ls()\n    const remoteServices = await Promise.all(offlineListOfServices.map(service => parseService(service, remoteServiceTemplates, ipfs)))\n    dispatch({ type: 'SET_REMOTE_PINNING_SERVICES', payload: remoteServices })\n  },\n\n  // fetching pin stats for services is slower/expensive, so we only do that on Settings\n  doFetchPinningServicesStats: () => async ({ getIpfs, store, dispatch }) => {\n    const ipfs = getIpfs()\n    if (!ipfs || store?.ipfs?.ipfs?.ready || !ipfs.pin.remote) return null\n    const isPinRemotePresent = (await ipfs.commands()).Subcommands.find(c => c.Name === 'pin').Subcommands.some(c => c.Name === 'remote')\n    if (!isPinRemotePresent) return null\n\n    const remoteServiceTemplates = store.selectRemoteServiceTemplates()\n    const servicesWithStats = await ipfs.pin.remote.service.ls({ stat: true })\n    const remoteServices = await Promise.all(servicesWithStats.map(service => parseService(service, remoteServiceTemplates, ipfs)))\n\n    dispatch({ type: 'SET_REMOTE_PINNING_SERVICES', payload: remoteServices })\n  },\n\n  selectPinningServices: (state) => state.pinning.pinningServices || [],\n\n  selectRemoteServiceTemplates: () => pinningServiceTemplates,\n\n  selectArePinningServicesSupported: (state) => state.pinning.arePinningServicesSupported,\n\n  selectPinningServicesDefaults: () => pinningServiceTemplates.reduce((prev, curr) => ({\n    ...prev,\n    [curr.name]: {\n      ...curr,\n      nickname: curr.name\n    }\n  }), {}),\n\n  doDismissCompletedPin: (...pins) => async ({ dispatch }) => {\n    dispatch({ type: 'DISMISS_REMOTE_PINS', payload: { completed: pins } })\n  },\n\n  doDismissFailedPin: (...pins) => async ({ dispatch }) => {\n    dispatch({ type: 'DISMISS_REMOTE_PINS', payload: { failed: pins } })\n  },\n\n  doCancelPendingPin: (...pins) => async ({ getIpfs, dispatch }) => {\n    const ipfs = getIpfs()\n\n    for (const pin of pins) {\n      const [service, cid] = pin.split(':')\n      await ipfs.pin.remote.rm({ cid: [new CID(cid)], service })\n    }\n\n    dispatch({ type: 'UPDATE_REMOTE_PINS', payload: { removals: pins } })\n  },\n\n  doSetPinning: (file, services = [], wasLocallyPinned, previousRemotePins = []) => async ({ getIpfs, store, dispatch }) => {\n    const ipfs = getIpfs()\n    const { cid, name } = file\n\n    const pinLocally = services.includes('local')\n    if (wasLocallyPinned !== pinLocally) {\n      try {\n        const msgArgs = { serviceName: 'Local node' }\n        if (pinLocally) {\n          await ipfs.pin.add(cid)\n          dispatch({ type: 'IPFS_PIN_SUCCEED', msgArgs })\n        } else {\n          await ipfs.pin.rm(cid)\n          dispatch({ type: 'IPFS_UNPIN_SUCCEED', msgArgs })\n        }\n      } catch (e) {\n        console.error(`unexpected local pin error for ${cid} (${name})`, e)\n        const msgArgs = { serviceName: 'local', errorMsg: e.toString() }\n        dispatch({ type: 'IPFS_PIN_FAILED', msgArgs })\n      }\n    }\n\n    const adds = []\n    const pending = []\n    const failed = []\n    const removals = []\n\n    store.selectPinningServices().forEach(async service => {\n      const shouldPin = services.includes(service.name)\n      const wasPinned = previousRemotePins.includes(service.name)\n      if (wasPinned === shouldPin) return\n\n      const id = `${service.name}:${cid}`\n      try {\n        const msgArgs = { serviceName: service.name }\n        if (shouldPin) {\n          pending.push(id)\n          await ipfs.pin.remote.add(cid, { service: service.name, name, background: true })\n          dispatch({ type: 'IPFS_PIN_SUCCEED', msgArgs })\n        } else {\n          removals.push(id)\n          await ipfs.pin.remote.rm({ cid: [cid], service: service.name })\n          dispatch({ type: 'IPFS_UNPIN_SUCCEED', msgArgs })\n        }\n      } catch (e) {\n        // log error and continue with other services\n        console.error(`ipfs.pin.remote error for ${cid}@${service.name}`, e)\n        const msgArgs = { serviceName: service.name, errorMsg: e.toString() }\n        failed.push(id)\n        dispatch({ type: 'IPFS_PIN_FAILED', msgArgs })\n      }\n    })\n\n    dispatch({ type: 'UPDATE_REMOTE_PINS', payload: { adds, removals, pending, failed } })\n\n    await store.doPinsFetch()\n  },\n  doAddPinningService: ({ apiEndpoint, nickname, secretApiKey }) => async ({ getIpfs }) => {\n    const ipfs = getIpfs()\n\n    // temporary mitigation for https://github.com/ipfs/ipfs-webui/issues/1770\n    // update: still present a year later – i think there is a lesson here :-)\n    nickname = nickname.replaceAll('.', '_')\n\n    await ipfs.pin.remote.service.add(nickname, {\n      endpoint: apiEndpoint,\n      key: secretApiKey\n    })\n  },\n\n  doRemovePinningService: (name) => async ({ getIpfs, store }) => {\n    const ipfs = getIpfs()\n\n    await ipfs.pin.remote.service.rm(name)\n\n    store.doFetchPinningServices()\n  },\n\n  doSetAutoUploadForService: (name) => async ({ getIpfs, store }) => {\n    const ipfs = getIpfs()\n\n    const configName = `Pinning.RemoteServices.${name}.Policies.MFS.Enable`\n\n    const previousPolicy = await ipfs.config.get(configName)\n\n    await ipfs.config.set(configName, !previousPolicy)\n\n    store.doFetchPinningServices()\n  }\n}\nexport default pinningBundle\n","import React from 'react'\nimport Loadable from '@loadable/component'\nimport ComponentLoader from '../loader/ComponentLoader.js'\n\nconst LoadableStatusPage = Loadable(() => import('./StatusPage'),\n  { fallback: <ComponentLoader/> }\n)\n\nexport default LoadableStatusPage\n","import React from 'react'\nimport Loadable from '@loadable/component'\nimport ComponentLoader from '../loader/ComponentLoader.js'\n\nconst LoadableFilesPage = Loadable(() => import('./FilesPage'),\n  { fallback: <ComponentLoader/> }\n)\n\nexport default LoadableFilesPage\n","import React from 'react'\nimport Loadable from '@loadable/component'\nimport ComponentLoader from '../loader/ComponentLoader.js'\n\nconst LoadablePinsPage = Loadable(() => import('./PinsPage'),\n  { fallback: <ComponentLoader/> }\n)\n\nexport default LoadablePinsPage\n","import React from 'react'\nimport Loadable from '@loadable/component'\nimport ComponentLoader from '../loader/ComponentLoader.js'\n\nconst LoadableStartExploringPage = Loadable(() => import('./StartExploringContainer'),\n  { fallback: <ComponentLoader/> }\n)\n\nexport default LoadableStartExploringPage\n","import React from 'react'\nimport Loadable from '@loadable/component'\nimport ComponentLoader from '../loader/ComponentLoader.js'\n\nconst LoadableExplorePage = Loadable(() => import('./ExploreContainer'),\n  { fallback: <ComponentLoader/> }\n)\n\nexport default LoadableExplorePage\n","import React from 'react'\nimport Loadable from '@loadable/component'\nimport ComponentLoader from '../loader/ComponentLoader.js'\n\nconst LoadablePeersPage = Loadable(() => import('./PeersPage'),\n  { fallback: <ComponentLoader/> }\n)\n\nexport default LoadablePeersPage\n","import React from 'react'\nimport Loadable from '@loadable/component'\nimport ComponentLoader from '../loader/ComponentLoader.js'\n\nconst LoadableSettingsPage = Loadable(() => import('./SettingsPage'),\n  { fallback: <ComponentLoader/> }\n)\n\nexport default LoadableSettingsPage\n","import React from 'react'\nimport { Helmet } from 'react-helmet'\nimport { withTranslation } from 'react-i18next'\nimport Title from './Title'\nimport Box from '../components/box/Box'\nimport AnalyticsToggle from '../components/analytics-toggle/AnalyticsToggle'\n\nexport const AnalyticsPage = ({ t }) => (\n  <div data-id='AnalyticsPage' className='mw9 center'>\n    <Helmet>\n      <title>{t('title')} | IPFS</title>\n    </Helmet>\n\n    <Box>\n      <Title>{t('analytics')}</Title>\n      <AnalyticsToggle t={t} open />\n    </Box>\n  </div>\n)\n\nexport default withTranslation('settings')(AnalyticsPage)\n","import React from 'react'\nimport Loadable from '@loadable/component'\nimport ComponentLoader from '../loader/ComponentLoader.js'\n\nconst LoadableWelcomePage = Loadable(() => import('./WelcomePage'),\n  { fallback: <ComponentLoader/> }\n)\n\nexport default LoadableWelcomePage\n","import React from 'react'\n\nconst BlankPage = () => (\n  <div data-id='BlankPage' />\n)\n\nexport default BlankPage\n","import { createRouteBundle } from 'redux-bundler'\nimport StatusPage from '../status/LoadableStatusPage'\nimport FilesPage from '../files/LoadableFilesPage'\nimport PinsPage from '../pins/LoadablePinsPage'\nimport StartExploringPage from '../explore/LoadableStartExploringPage'\nimport ExplorePage from '../explore/LoadableExplorePage'\nimport PeersPage from '../peers/LoadablePeersPage'\nimport SettingsPage from '../settings/LoadableSettingsPage'\nimport AnalyticsPage from '../settings/AnalyticsPage'\nimport WelcomePage from '../welcome/LoadableWelcomePage'\nimport BlankPage from '../blank/BlankPage'\n\nexport default createRouteBundle({\n  '/explore': StartExploringPage,\n  '/explore*': ExplorePage,\n  '/files*': FilesPage,\n  '/ipfs*': FilesPage,\n  '/ipns*': FilesPage,\n  '/pins*': PinsPage,\n  '/peers': PeersPage,\n  '/settings/analytics': AnalyticsPage,\n  '/settings*': SettingsPage,\n  '/welcome': WelcomePage,\n  '/blank': BlankPage,\n  '/status*': StatusPage,\n  '/': StatusPage,\n  '': StatusPage\n}, { routeInfoSelector: 'selectHash' })\n","import { createSelector } from 'redux-bundler'\n\nconst redirectsBundle = {\n  name: 'redirects',\n\n  reactToEmptyHash: createSelector(\n    'selectHash',\n    (hash) => {\n      if (hash === '') {\n        return { actionCreator: 'doUpdateHash', args: ['#/'] }\n      }\n    }\n  ),\n\n  reactToIpfsConnectionFail: createSelector(\n    'selectIpfsInitFailed',\n    'selectHash',\n    (failed, hash) => {\n      if (failed && hash !== '/welcome' && !hash.startsWith('/settings')) {\n        return { actionCreator: 'doUpdateHash', args: ['#/welcome'] }\n      }\n    }\n  )\n}\nexport default redirectsBundle\n","import memoize from 'p-memoize'\nimport toUri from 'multiaddr-to-uri'\nimport { createAsyncResourceBundle, createSelector } from 'redux-bundler'\n\nconst LOCAL_HOSTNAMES = ['127.0.0.1', '[::1]', '0.0.0.0', '[::]']\n\nconst bundle = createAsyncResourceBundle({\n  name: 'config',\n  staleAfter: 60000,\n  persist: false,\n  checkIfOnline: false,\n\n  getPromise: async ({ getIpfs, store }) => {\n    const rawConf = await getIpfs().config.getAll()\n    let conf\n\n    if (Buffer.isBuffer(rawConf)) {\n      conf = rawConf.toString()\n    } else {\n      conf = JSON.stringify(rawConf, null, '\\t')\n    }\n\n    const config = JSON.parse(conf)\n\n    const publicGateway = store.selectPublicGateway()\n    const url = getURLFromAddress('Gateway', config) || publicGateway\n\n    // Normalize local hostnames to localhost\n    // to leverage subdomain gateway, if present\n    // https://github.com/ipfs-shipyard/ipfs-webui/issues/1490\n    const gw = new URL(url)\n    if (LOCAL_HOSTNAMES.includes(gw.hostname)) {\n      gw.hostname = 'localhost'\n      const localUrl = gw.toString().replace(/\\/+$/, '') // no trailing slashes\n      if (await checkIfSubdomainGatewayUrlIsAccessible(localUrl)) {\n        store.doSetAvailableGateway(localUrl)\n        return conf\n      }\n    }\n\n    if (!await checkIfGatewayUrlIsAccessible(url)) {\n      store.doSetAvailableGateway(publicGateway)\n    }\n\n    // stringy json for quick compares\n    return conf\n  }\n})\n\n// derive the object from the stringy json\nbundle.selectConfigObject = createSelector(\n  'selectConfig',\n  (configStr) => JSON.parse(configStr)\n)\n\nbundle.selectApiUrl = createSelector(\n  'selectConfigObject',\n  'selectPublicGateway',\n  (config, publicGateway) => getURLFromAddress('API', config) || publicGateway\n)\n\nbundle.selectGatewayUrl = createSelector(\n  'selectConfigObject',\n  'selectPublicGateway',\n  (config, publicGateway) => getURLFromAddress('Gateway', config) || publicGateway\n)\n\nbundle.selectAvailableGatewayUrl = createSelector(\n  'selectAvailableGateway',\n  'selectGatewayUrl',\n  (availableGateway, gatewayUrl) => availableGateway || gatewayUrl\n)\n\nbundle.selectBootstrapPeers = createSelector(\n  'selectConfigObject',\n  (config) => config && config.Bootstrap\n)\n\n// TODO: this is a work-around for IPFS companion blocking the config API\n// see: https://github.com/ipfs-shipyard/ipfs-companion/issues/454\nbundle.selectIsConfigBlocked = createSelector(\n  'selectConfigRaw',\n  ({ errorType }) => errorType === 'Access to config.get API is globally blocked for window.ipfs'\n)\n\n// Fetch the config if we don't have it or it's more than `staleAfter` ms old\nbundle.reactConfigFetch = createSelector(\n  'selectConfigShouldUpdate',\n  'selectIpfsReady',\n  (shouldUpdate, ipfsReady) => {\n    if (shouldUpdate && ipfsReady) {\n      return { actionCreator: 'doFetchConfig' }\n    }\n  }\n)\n\nfunction getURLFromAddress (name, config) {\n  if (!config) return null\n\n  try {\n    const address = Array.isArray(config.Addresses[name])\n      ? config.Addresses[name][0]\n      : config.Addresses[name]\n    const url = toUri(address, { assumeHttp: true })\n    if (new URL(url).port === 0) throw Error('port set to 0, not deterministic')\n    return url\n  } catch (error) {\n    console.log(`Failed to get url from config at Addresses.${name}`, error)\n    return null\n  }\n}\n\nconst checkIfGatewayUrlIsAccessible = memoize(async (url) => {\n  try {\n    const { status } = await fetch(\n    `${url}/ipfs/bafkqae2xmvwgg33nmuqhi3zajfiemuzahiwss`\n    )\n    return status === 200\n  } catch (e) {\n    console.error(`Unable to use the gateway at ${url}. The public gateway will be used as a fallback`, e)\n    return false\n  }\n})\n\n// Separate test is necessary to see if subdomain mode is possible,\n// because some browser+OS combinations won't resolve them:\n// https://github.com/ipfs/kubo/issues/7527\nconst checkIfSubdomainGatewayUrlIsAccessible = memoize(async (url) => {\n  try {\n    url = new URL(url)\n    url.hostname = `bafkqae2xmvwgg33nmuqhi3zajfiemuzahiwss.ipfs.${url.hostname}`\n    const { status } = await fetch(url.toString())\n    return status === 200\n  } catch (e) {\n    console.error(`Unable to use the subdomain gateway at ${url}. Regular gateway will be used as a fallback`, e)\n    return false\n  }\n})\n\nexport default bundle\n","// @ts-check\n\nimport * as Enum from './enum'\nimport { perform } from './task'\n\n/**\n * @typedef {import('./task').Perform<'CONFIG_SAVE', Error, void, void>} ConfigSave\n *\n * @typedef {ConfigSave} Message\n *\n * @typedef {Object} Model\n * @property {boolean} isSaving\n * @property {number} [lastSuccess]\n * @property {number} [lastError]\n * @property {string} [errorMessage]\n *\n * @typedef {Object} State\n * @property {Model} config_save\n */\n\n/**\n * @typedef {import('redux-bundler').Selectors<typeof selectors>} Selectors\n */\n\nconst selectors = {\n  /**\n   * @param {State} state\n   */\n  selectConfigIsSaving: state => state.config_save.isSaving,\n  /**\n   * @param {State} state\n   */\n  selectConfigSaveLastSuccess: state => state.config_save.lastSuccess,\n  /**\n   * @param {State} state\n   */\n  selectConfigSaveLastError: state => state.config_save.lastError\n}\n\n/**\n * @typedef {import('redux-bundler').Actions<typeof actions>} Actions\n * @typedef {import('./ipfs-provider').Extra} Extra\n * @typedef {Selectors & Actions} Ext\n * @typedef {import('redux-bundler').Context<State, Message, Ext, Extra>} Context\n */\n\nconst actions = {\n  /**\n   * @param {string} configStr\n   * @returns {function(Context):Promise<void>}\n   */\n  doSaveConfig: (configStr) => async ({ store }) => {\n    if (store.selectConfigIsSaving()) {\n      console.log('doSaveConfig skipped, config save already in progress')\n    } else {\n      await store.doPerformSaveConfig(configStr)\n    }\n  },\n\n  /**\n   * @param {string} configStr\n   * @returns {function(Context):Promise<void>}\n   */\n  doPerformSaveConfig: (configStr) => perform('CONFIG_SAVE', async (context) => {\n    const result = await attempt(async () => {\n      const obj = JSON.parse(configStr)\n      const ipfs = context.getIpfs()\n      if (ipfs == null) {\n        throw Error('IPFS node is not found')\n      }\n\n      await ipfs.config.replace(obj)\n    })\n\n    if (!result.ok) {\n      throw result.error\n    }\n\n    // @ts-ignore - Nor TS nor @gozala can tell where below function is defined\n    // but it does appear to exist at runtime 🤷‍♂️\n    await context.store.doMarkConfigAsOutdated()\n  })\n}\n\n/**\n * @template T\n * @param {() => Promise<T>} fn\n * @returns {Promise<{ok:true, value:T}|{ok:false, error:Error}>}\n */\nconst attempt = async (fn) => {\n  try {\n    const value = await fn()\n    return { ok: true, value }\n  } catch (err) {\n    const error = /** @type {Error} */(err)\n    return { ok: false, error }\n  }\n}\n\nexport const ACTIONS = Enum.from(['CONFIG_SAVE'])\n\nconst bundle = {\n  name: 'config_save',\n\n  /**\n   * @param {Model} state\n   * @param {Message} action\n   * @returns {Model}\n   */\n  reducer: (state = { isSaving: false }, action) => {\n    switch (action.type) {\n      case ACTIONS.CONFIG_SAVE: {\n        const { task } = action\n        switch (task.status) {\n          case 'Init': {\n            return { ...state, isSaving: true }\n          }\n          case 'Exit': {\n            const { result } = task\n            if (result.ok) {\n              return { ...state, isSaving: false, lastSuccess: Date.now() }\n            } else {\n              const { error } = result\n              const errorMessage = (error && error.message) || String(error)\n              return { ...state, isSaving: false, lastError: Date.now(), errorMessage }\n            }\n          }\n          default: {\n            return state\n          }\n        }\n      }\n      default: {\n        return state\n      }\n    }\n  },\n\n  ...selectors,\n  ...actions\n}\n\nexport default bundle\n","import root from 'window-or-global'\n\nconst toursBundle = {\n  name: 'tours',\n\n  init: (store) => {\n    const tourTooltip = root.localStorage.getItem('tourTooltip')\n\n    if (tourTooltip) {\n      store.doDisableTooltip()\n    }\n  },\n\n  reducer: (state = { enabled: false, tooltip: true }, action) => {\n    if (action.type === 'TOURS_ENABLE') {\n      return { ...state, enabled: true }\n    }\n\n    if (action.type === 'TOURS_DISABLE') {\n      return { ...state, enabled: false }\n    }\n\n    if (action.type === 'TOURS_TOOLTIP_DISABLE') {\n      return { ...state, tooltip: false }\n    }\n\n    return state\n  },\n\n  doDisableTooltip: () => ({ dispatch }) => {\n    root.localStorage.setItem('tourTooltip', false)\n    dispatch({ type: 'TOURS_TOOLTIP_DISABLE' })\n  },\n\n  doEnableTours: () => ({ dispatch }) => {\n    dispatch({ type: 'TOURS_ENABLE' })\n  },\n\n  doDisableTours: () => ({ dispatch }) => {\n    dispatch({ type: 'TOURS_DISABLE' })\n  },\n\n  selectTours: state => state.tours,\n\n  selectToursEnabled: state => state.tours.enabled,\n\n  selectShowTooltip: state => state.tours.tooltip\n}\nexport default toursBundle\n","import { createSelector } from 'redux-bundler'\nimport * as Enum from './enum'\nexport const ACTIONS = Enum.from([\n  'EXPERIMENTS_TOGGLE',\n  'EXPERIMENTS_UPDATE_STATE'\n])\n\n/**\n * @typedef {import('./task').Perform<'EXPERIMENTS_TOGGLE', Fail, Succeed, Init>} Toggle\n * @typedef {Object} Succeed\n * @property {string} key\n * @property {boolean} value\n *\n * @typedef {Object} Fail\n * @property {string} key\n * @property {string} message\n *\n * @typedef {Object} Init\n * @property {string} key\n *\n * @typedef {Object} UpdateState\n * @property {'EXPERIMENTS_UPDATE_STATE'} type\n * @property {Model} payload\n *\n * @typedef {Toggle|UpdateState} Message\n *\n * @typedef {Record<string, {blocked:boolean, enabled:boolean}>} Model\n *\n * @typedef {Object} State\n * @property {Model} experiments\n */\n\n/**\n * @type {Array<{key:string}>}\n */\nconst EXPERIMENTS = []\n\n/**\n *\n * @param {Model} state\n * @param {Model} payload\n * @returns {Model}\n */\nconst mergeState = (state, payload) =>\n  Object.keys(payload).reduce(\n    (all, key) => ({\n      ...all,\n      [key]: {\n        ...state[key],\n        ...payload[key]\n      }\n    }),\n    state\n  )\n\n/**\n * @param {Model} state\n * @param {string} key\n * @returns {Model}\n */\nconst toggleEnabled = (state, key) => {\n  return unblock(\n    {\n      ...state,\n      [key]: {\n        ...state[key],\n        enabled: !(state && state[key] && state[key].enabled)\n      }\n    },\n    key\n  )\n}\n\n/**\n * @param {Model} state\n * @param {string} key\n * @returns {Model}\n */\nconst unblock = (state, key) => {\n  return {\n    ...state,\n    [key]: {\n      ...state[key],\n      blocked: false\n    }\n  }\n}\n\n/**\n * @param {Model} state\n * @param {string} key\n * @returns {Model}\n */\nconst block = (state, key) => {\n  return {\n    ...state,\n    [key]: {\n      ...state[key],\n      blocked: true\n    }\n  }\n}\n\n/**\n * @typedef {import('redux-bundler').Selectors<typeof selectors>} Selectors\n */\n\nconst selectors = {\n  /**\n   * @param {State} state\n   */\n  selectExperimentsState: state => state.experiments,\n\n  selectExperiments: createSelector(\n    'selectExperimentsState',\n    /**\n     * @param {Model} state\n     */\n    (state) =>\n      EXPERIMENTS.map(e => ({\n        ...e,\n        ...state[e.key]\n      }))\n  )\n}\n\n/**\n * @typedef {import('redux-bundler').Actions<typeof actions>} Actions\n * @typedef {Selectors & Actions} Ext\n * @typedef {import('redux-bundler').Context<State, Message, Ext>} Context\n */\n\nconst actions = {\n  /**\n   * @param {string} key\n   * @returns {function(Context): void}\n   */\n  doExpToggleAction: key => ({ dispatch }) => {\n    if (!key) return\n\n    dispatch({\n      type: ACTIONS.EXPERIMENTS_TOGGLE,\n      task: {\n        status: 'Init',\n        id: Symbol(ACTIONS.EXPERIMENTS_TOGGLE),\n        init: { key }\n      }\n    })\n  }\n}\n\nconst experimentsBundle = {\n  name: 'experiments',\n\n  persistActions: [\n    ACTIONS.EXPERIMENTS_TOGGLE,\n    ACTIONS.EXPERIMENTS_UPDATE_STATE\n  ],\n\n  /**\n   * @param {Model} state\n   * @param {Message} action\n   * @returns {Model}\n   */\n  reducer: (state = {}, action) => {\n    switch (action.type) {\n      case ACTIONS.EXPERIMENTS_TOGGLE: {\n        const { task } = action\n        switch (task.status) {\n          case 'Init': {\n            return block(state, task.init.key)\n          }\n          case 'Exit': {\n            const { result } = task\n            if (result.ok) {\n              return toggleEnabled(state, result.value.key)\n            } else {\n              return unblock(state, result.error.key)\n            }\n          }\n          default: {\n            return state\n          }\n        }\n      }\n      case ACTIONS.EXPERIMENTS_UPDATE_STATE: {\n        return mergeState(state, action.payload)\n      }\n\n      default:\n        return state\n    }\n  },\n\n  ...selectors,\n  ...actions\n}\nexport default experimentsBundle\n","import { createSelector } from 'redux-bundler'\nimport { ACTIONS as EXP_ACTIONS } from './experiments'\nimport { ACTIONS as FILES_ACTIONS } from './files'\n\n/*\n# Notify\n- show error when ipfs goes away.\n- show ok when it comes back.\n- dismiss the ok after 3s\n*/\n\nconst defaultState = {\n  show: false,\n  error: false,\n  eventId: null,\n  code: null\n}\n\nconst notify = {\n  name: 'notify',\n\n  reducer: (state = defaultState, action) => {\n    if (action.type === 'NOTIFY_DISMISSED') {\n      return { ...state, show: false }\n    }\n\n    if (action.type === 'STATS_FETCH_FAILED') {\n      return {\n        ...state,\n        show: true,\n        error: true,\n        eventId: action.type\n      }\n    }\n\n    if (action.type.match(/^FILES_\\w+_FAILED$/)) {\n      return {\n        ...state,\n        show: true,\n        error: true,\n        eventId: 'FILES_EVENT_FAILED',\n        code: action.payload.error.code\n      }\n    }\n\n    if (action.type === 'STATS_FETCH_FINISHED' && state.eventId === 'STATS_FETCH_FAILED') {\n      return {\n        ...state,\n        error: false,\n        eventId: 'STATS_FETCH_FINISHED',\n        lastSuccess: Date.now()\n      }\n    }\n\n    if (action.type === 'SWARM_CONNECT_FAILED' || action.type === 'SWARM_CONNECT_FINISHED') {\n      return {\n        ...state,\n        show: true,\n        error: action.type === 'SWARM_CONNECT_FAILED',\n        eventId: action.type\n      }\n    }\n\n    if (action.type === EXP_ACTIONS.EXP_TOGGLE_FAILED) {\n      return {\n        ...state,\n        show: true,\n        error: true,\n        eventId: `experimentsErrors.${action.payload.key}`\n      }\n    }\n\n    if (action.type === 'IPFS_PIN_FAILED') {\n      return {\n        ...state,\n        show: true,\n        error: true,\n        msgArgs: action.msgArgs,\n        eventId: action.type\n      }\n    }\n\n    if (action.type === 'IPFS_PIN_SUCCEED') {\n      return {\n        ...state,\n        show: true,\n        error: false,\n        msgArgs: action.msgArgs,\n        eventId: action.type\n      }\n    }\n\n    if (action.type === 'IPFS_UNPIN_SUCCEED') {\n      return {\n        ...state,\n        show: true,\n        error: false,\n        msgArgs: action.msgArgs,\n        eventId: action.type\n      }\n    }\n\n    if (action.type === 'IPFS_CONNECT_FAILED') {\n      return {\n        ...state,\n        show: true,\n        error: true,\n        eventId: action.type\n      }\n    }\n\n    if (action.type === 'IPFS_CONNECT_SUCCEED') {\n      return {\n        ...state,\n        show: true,\n        error: false,\n        eventId: action.type\n      }\n    }\n\n    if (action.type === 'IPFS_API_ADDRESS_INVALID') {\n      return {\n        ...state,\n        show: true,\n        error: true,\n        eventId: action.type\n      }\n    }\n\n    return state\n  },\n\n  selectNotify: state => state.notify,\n\n  selectNotifyI18nKey: createSelector(\n    'selectNotify',\n    'selectIpfsProvider',\n    (notify, provider) => {\n      const { eventId, code } = notify\n\n      if (eventId === 'STATS_FETCH_FAILED') {\n        return provider === 'window.ipfs' ? 'windowIpfsRequestFailed' : 'ipfsApiRequestFailed'\n      }\n      if (eventId === 'IPFS_CONNECT_FAILED') {\n        return 'ipfsConnectFail'\n      }\n      if (eventId === 'IPFS_CONNECT_SUCCEED') {\n        return 'ipfsConnectSuccess'\n      }\n      if (eventId === 'IPFS_API_ADDRESS_INVALID') {\n        return 'ipfsInvalidApiAddress'\n      }\n      if (eventId === 'IPFS_PIN_FAILED') {\n        return 'ipfsPinFailReason'\n      }\n      if (eventId === 'IPFS_PIN_SUCCEED') {\n        return 'ipfsPinSucceedReason'\n      }\n      if (eventId === 'IPFS_UNPIN_SUCCEED') {\n        return 'ipfsUnpinSucceedReason'\n      }\n\n      if (eventId === 'FILES_EVENT_FAILED') {\n        const type = code ? code.replace(/^(ERR_)/, '') : ''\n\n        switch (type) {\n          case 'FOLDER_EXISTS':\n            return 'folderExists'\n          case FILES_ACTIONS.WRITE:\n          case FILES_ACTIONS.ADD_BY_PATH:\n          case 'API_RESPONSE':\n            return 'filesAddFailed'\n          case FILES_ACTIONS.FETCH:\n            return 'filesFetchFailed'\n          case FILES_ACTIONS.MOVE:\n            return 'filesRenameFailed'\n          case FILES_ACTIONS.MAKE_DIR:\n            return 'filesMakeDirFailed'\n          case FILES_ACTIONS.COPY:\n            return 'filesCopyFailed'\n          case FILES_ACTIONS.DELETE:\n            return 'filesRemoveFailed'\n          default:\n            return 'filesEventFailed'\n        }\n      }\n\n      if (eventId === 'STATS_FETCH_FINISHED') {\n        return 'ipfsIsBack'\n      }\n\n      if (eventId === 'SWARM_CONNECT_FAILED') {\n        return 'couldntConnectToPeer'\n      }\n\n      if (eventId === 'SWARM_CONNECT_FINISHED') {\n        return 'connectedToPeer'\n      }\n\n      return eventId\n    }\n  ),\n\n  doNotifyDismiss: () => ({ dispatch }) => dispatch({ type: 'NOTIFY_DISMISSED' }),\n\n  // Dismiss the \"all ok\" message after 3 seconds\n  reactNotifyOkDismiss: createSelector(\n    'selectAppTime',\n    'selectNotify',\n    (appTime, notify) => {\n      if (notify.eventId === 'STATS_FETCH_FINISHED' && notify.show && appTime - notify.lastSuccess > 3000) {\n        return { type: 'NOTIFY_DISMISSED' }\n      }\n    }\n  )\n}\n\nexport default notify\n","import { createSelector } from 'redux-bundler'\n\n/**\n * @typedef {Object} Model\n * @property {number} lastError\n * @property {boolean} isNodeInfoOpen\n *\n * @typedef {FetchFailed|InfoOpen} Message\n *\n * @typedef {Object} FetchFailed\n * @property {'STATS_FETCH_FAILED'} type\n *\n * @typedef {Object} InfoOpen\n * @property {'NODE_INFO_OPEN'} type\n * @property {boolean} payload\n *\n * @typedef {Object} State\n * @property {Model} connected\n *\n * @typedef {import('redux-bundler').Selectors<typeof selectors>} Selectors\n */\n\nconst selectors = {\n  /**\n   * @param {State} state\n   */\n  selectConnectedLastError: state => state.connected.lastError,\n\n  selectIpfsConnected: createSelector(\n    'selectIpfsReady',\n    'selectNodeBandwidthLastSuccess',\n    'selectNodeBandwidthLastError',\n    /**\n     * @param {boolean} ipfsReady\n     * @param {number|void} lastSuccess\n     * @param {number} lastError\n     * @returns {boolean}\n     */\n    (ipfsReady, lastSuccess, lastError) =>\n      ipfsReady && lastSuccess != null && lastSuccess > lastError\n  ),\n\n  /**\n   * @param {State} state\n   */\n  selectIsNodeInfoOpen: state => state.connected.isNodeInfoOpen\n}\n\n/**\n * @typedef {import('redux-bundler').Actions<typeof actions>} Actions\n * @typedef {Selectors & Actions} Ext\n * @typedef {import('redux-bundler').Context<State, Message, Ext>} Context\n */\nconst actions = {\n  /**\n   * @param {boolean} value\n   * @returns {function(Context): void}\n   */\n  doSetIsNodeInfoOpen: value => ({ dispatch }) => dispatch({ type: 'NODE_INFO_OPEN', payload: value })\n}\n\n// We ask for the stats every few seconds, so that gives a good indication\n// that ipfs things are working (or not), without additional polling of the api.\nconst connected = {\n  name: 'connected',\n\n  /**\n   * @param {Model|void} state\n   * @param {Message} action\n   * @returns {Model}\n   */\n  reducer: (state, action) => {\n    state = state || { lastError: 0, isNodeInfoOpen: false }\n    switch (action.type) {\n      case 'STATS_FETCH_FAILED':\n        return { ...state, lastError: Date.now() }\n      case 'NODE_INFO_OPEN':\n        return { ...state, isNodeInfoOpen: action.payload }\n      default:\n        return state\n    }\n  },\n  ...actions,\n  ...selectors\n}\n\nexport default connected\n","import { createSelector } from 'redux-bundler'\nimport { ACTIONS } from './ipfs-provider'\n\n/**\n * @typedef {import('./ipfs-provider').Message} Message\n * @typedef {Object} Model\n * @property {number} [startedAt]\n * @property {number} [failedAt]\n *\n * @typedef {Object} State\n * @property {Model} retryInit\n */\n\n// We ask for the stats every few seconds, so that gives a good indication\n// that ipfs things are working (or not), without additional polling of the api.\nconst retryInit = {\n  name: 'retryInit',\n\n  /**\n   * @param {Model} state\n   * @param {Message} action\n   * @returns {Model}\n   */\n  reducer: (state = {}, action) => {\n    switch (action.type) {\n      case ACTIONS.IPFS_INIT: {\n        const { task } = action\n        switch (task.status) {\n          case 'Init': {\n            return { ...state, startedAt: Date.now() }\n          }\n          case 'Exit': {\n            if (task.result.ok) {\n              return state\n            } else {\n              return { ...state, failedAt: Date.now() }\n            }\n          }\n          default: {\n            return state\n          }\n        }\n      }\n      default: {\n        return state\n      }\n    }\n  },\n\n  /**\n   * @param {State} state\n   */\n  selectInitStartedAt: state => state.retryInit.startedAt,\n\n  /**\n   * @param {State} state\n   */\n  selectInitFailedAt: state => state.retryInit.failedAt,\n\n  reactConnectionInitRetry: createSelector(\n    'selectAppTime',\n    'selectInitStartedAt',\n    'selectInitFailedAt',\n    /**\n     * @param {number} appTime\n     * @param {number|void} startedAt\n     * @param {number|void} failedAt\n     */\n    (appTime, startedAt, failedAt) => {\n      if (!failedAt || failedAt < startedAt) return false\n      if (appTime - failedAt < 3000) return false\n      return { actionCreator: 'doTryInitIpfs' }\n    }\n  )\n}\n\nexport default retryInit\n","import { createAsyncResourceBundle, createSelector } from 'redux-bundler'\n\nconst bundle = createAsyncResourceBundle({\n  name: 'identity',\n  actionBaseType: 'IDENTITY',\n  getPromise: ({ getIpfs }) => getIpfs().id().catch((err) => {\n    console.error('Failed to get identity', err)\n  }),\n  staleAfter: Infinity,\n  persist: false,\n  checkIfOnline: false\n})\n\nbundle.selectIdentityLastSuccess = state => state.identity.lastSuccess\n\n// Update identity after we (re)connect with ipfs\nbundle.reactIdentityFetch = createSelector(\n  'selectIpfsConnected',\n  'selectIdentityIsLoading',\n  'selectIdentityLastSuccess',\n  'selectConnectedLastError',\n  (connected, isLoading, idLastSuccess, connLastError) => {\n    if (connected && !isLoading) {\n      if (!idLastSuccess || connLastError > idLastSuccess) {\n        return { actionCreator: 'doFetchIdentity' }\n      }\n    }\n  }\n)\n\nexport default bundle\n","import { getConfiguredCache } from 'money-clip'\n\nconst bundleCache = getConfiguredCache({\n  name: 'bundle-cache',\n  version: 1,\n  maxAge: Infinity\n})\n\nexport default bundleCache\n","/**\n * @typedef {Object} IPFSDesktop\n * @property {string} version\n * @property {string} countlyDeviceId\n * @property {string[]} countlyActions\n * @property {() => Promise<void|Array<{path:string, size:number, content:AsyncIterable<Uint8Array>}>>} selectDirectory\n * @property {(consent:string[]) => void} removeConsent\n * @property {(consent:string[]) => void} addConsent\n * @property {(language:string) => void} updateLanguage\n */\n\n// @ts-ignore\n/** @type {{ ipfsDesktop?: IPFSDesktop } & Window} */\nconst root = (window)\n\n/**\n * @typedef {import('redux-bundler').Selectors<typeof baseSelectors>} BaseSelectors\n */\n\nconst baseSelectors = {\n  /**\n   * @returns {boolean}\n   */\n  selectIsIpfsDesktop: () => !!root.ipfsDesktop,\n  /**\n   * @returns {string[]}\n   */\n  selectDesktopCountlyActions: () => ([])\n}\n\nconst desktopSelectors = {\n  ...baseSelectors,\n  selectDesktopVersion: () => root.ipfsDesktop?.version,\n\n  selectDesktopCountlyDeviceId: () => root.ipfsDesktop?.countlyDeviceId,\n\n  selectDesktopCountlyActions: () => root.ipfsDesktop?.countlyActions\n}\n\n/**\n * @typedef {import('redux-bundler').Selectors<typeof desktopSelectors>} Selectors\n */\nconst selectors = root.ipfsDesktop\n  ? desktopSelectors\n  : baseSelectors\n\nconst desktopActions = {\n  /**\n   * @param {string[]} consent\n   * @returns {() => void}\n   */\n  doDesktopAddConsent: consent => () => {\n    return root.ipfsDesktop?.addConsent(consent)\n  },\n\n  /**\n   * @param {string[]} consent\n   * @returns {() => void}\n   */\n  doDesktopRemoveConsent: consent => () => {\n    return root.ipfsDesktop?.removeConsent(consent)\n  },\n\n  /**\n   * @param {string} language\n   * @returns {() => void}\n   */\n  doDesktopUpdateLanguage: language => () => {\n    return root.ipfsDesktop?.updateLanguage(language)\n  }\n}\n\n/**\n * @typedef {never} Message\n * @typedef {Object} Model\n * @typedef {Object} State\n * @property {Model} ipfsDesktop\n * @typedef {import('redux-bundler').Actions<typeof desktopActions>} Actions\n * @typedef {Selectors & Actions} Ext\n * @typedef {import('redux-bundler').Context<State, Message, Ext>} Context\n */\n\nconst actions = root.ipfsDesktop\n  ? desktopActions\n  : {}\n\nconst bundle = {\n  name: 'ipfsDesktop',\n  /**\n   * @param {Model} [state]\n   * @returns {Model}\n   */\n  reducer: (state = {}) => state,\n  ...selectors,\n  ...actions\n}\n\nexport default bundle\n","import { createAsyncResourceBundle, createSelector } from 'redux-bundler'\n\nconst bundle = createAsyncResourceBundle({\n  name: 'repoStats',\n  getPromise: async ({ getIpfs }) => {\n    return getIpfs().repo.stat()\n  },\n  staleAfter: 60000,\n  persist: false,\n  checkIfOnline: false\n})\n\nbundle.selectRepoSize = createSelector(\n  'selectRepoStats',\n  (repoStats) => {\n    if (repoStats && repoStats.repoSize) {\n      return repoStats.repoSize.toString()\n    }\n  }\n)\n\nbundle.selectRepoNumObjects = createSelector(\n  'selectRepoStats',\n  (repoStats) => {\n    if (repoStats && repoStats.numObjects) {\n      return repoStats.numObjects.toString()\n    }\n  }\n)\n\n// Fetch the config if we don't have it or it's more than `staleAfter` ms old\nbundle.reactRepoStatsFetch = createSelector(\n  'selectRepoStatsShouldUpdate',\n  'selectIpfsReady',\n  (shouldUpdate, ipfsReady) => {\n    if (shouldUpdate && ipfsReady) {\n      return { actionCreator: 'doFetchRepoStats' }\n    }\n  }\n)\n\nexport default bundle\n","// @ts-check\n\n// @ts-ignore\nimport root from 'window-or-global'\nimport changeCase from 'change-case'\nimport * as Enum from './enum'\nimport { createSelector } from 'redux-bundler'\nimport { ACTIONS as FILES } from './files/consts'\nimport { ACTIONS as CONIFG } from './config-save'\nimport { ACTIONS as INIT } from './ipfs-provider'\nimport { ACTIONS as EXP } from './experiments'\n\n/**\n * @typedef {import('./ipfs-provider').Init} Init\n * @typedef {import('./files/protocol').MakeDir} MakeDir\n * @typedef {import('./files/protocol').Write} Write\n * @typedef {import('./files/protocol').AddByPath} AddByPath\n * @typedef {import('./files/protocol').Move} Move\n * @typedef {import('./files/protocol').Delete} Delete\n * @typedef {import('./files/protocol').DownloadLink} DownloadLink\n * @typedef {import('./config-save').Message} ConfigSave\n * @typedef {import('./experiments').Toggle} ExperimentsToggle\n *\n * @typedef {Object} DesktopSettingToggleStarted\n * @property {'DESKTOP_SETTING_TOGGLE_STARTED'} type\n * @typedef {Object} DesktopSettingToggleFinished\n * @property {'DESKTOP_SETTING_TOGGLE_FINISHED'} type\n * @typedef {Object} DesktopSettingToggleFailed\n * @property {'DESKTOP_SETTING_TOGGLE_FAILED'} type\n *\n * @typedef {import('./experiments').Fail} FailToggle\n * @typedef {import('./experiments').Succeed} SucceedToggle\n * @typedef {import('./experiments').Init} InitToggle\n * @typedef {import('./task').Perform<'DESKTOP_SETTING_TOGGLE', FailToggle, SucceedToggle, InitToggle>} DesktopSettingToggle\n *\n * @typedef {Object} AnalyticsEnabled\n * @property {'ANALYTICS_ENABLED'} type\n * @property {{consent:string[]}} payload\n *\n * @typedef {Object} AnalyticsDisabled\n * @property {'ANALYTICS_DISABLED'} type\n * @property {{consent:string[]}} payload\n *\n * @typedef {Object} RemoveConsent\n * @property {'ANALYTICS_REMOVE_CONSENT'} type\n * @property {{name:string}} payload\n *\n * @typedef {Object} AddConsent\n * @property {'ANALYTICS_ADD_CONSENT'} type\n * @property {{name:string}} payload\n *\n * @typedef {ExperimentsToggle|DesktopSettingToggle} Toggle\n * @typedef {MakeDir|Write|AddByPath|Move|Delete|DownloadLink} FilesMessage\n * @typedef {AnalyticsEnabled|AnalyticsDisabled|RemoveConsent|AddConsent} AnalyticsMessage\n * @typedef {Init|ConfigSave|Toggle|FilesMessage|AnalyticsMessage} Message\n *\n * @typedef {Object} Model\n * @property {number} lastEnabledAt\n * @property {number} lastDisabledAt\n * @property {string[]} consent\n *\n * @typedef {Object} State\n * @property {Model} analytics\n */\n\n// Unknown actions (can't seem to see anything\n// dispatching those).\nconst DESKTOP = Enum.from(['DESKTOP_SETTING_TOGGLE'])\n\n// Local action types\nconst ACTIONS = Enum.from([\n  'ANALYTICS_ENABLED',\n  'ANALYTICS_DISABLED',\n  'ANALYTICS_ADD_CONSENT',\n  'ANALYTICS_REMOVE_CONSENT'\n])\n\n// Only record specific actions listed here.\nconst ASYNC_ACTIONS_TO_RECORD = [\n  INIT.IPFS_INIT,\n  CONIFG.CONFIG_SAVE,\n  FILES.MAKE_DIR,\n  FILES.WRITE,\n  FILES.ADD_BY_PATH,\n  FILES.MOVE,\n  FILES.DELETE,\n  FILES.DOWNLOAD_LINK,\n  EXP.EXPERIMENTS_TOGGLE,\n  DESKTOP.DESKTOP_SETTING_TOGGLE\n]\n\nconst COUNTLY_KEY_WEBUI = '8fa213e6049bff23b08e5f5fbac89e7c27397612'\nconst COUNTLY_KEY_WEBUI_TEST = '700fd825c3b257e021bd9dbc6cbf044d33477531'\n\nfunction pickAppKey () {\n  const isProd = process.env.NODE_ENV === 'production'\n\n  if (root.ipfsDesktop && root.ipfsDesktop.countlyAppKey) {\n    return root.ipfsDesktop.countlyAppKey\n  } else {\n    return isProd ? COUNTLY_KEY_WEBUI : COUNTLY_KEY_WEBUI_TEST\n  }\n}\n\nconst consentGroups = {\n  all: ['sessions', 'events', 'views', 'location', 'crashes'],\n  safe: ['sessions', 'events', 'views', 'location']\n}\n\n/**\n * @param {string|string[]} consent\n * @param {Store} store\n */\nfunction addConsent (consent, store) {\n  root.Countly.q.push(['add_consent', consent])\n\n  if (store.selectIsIpfsDesktop()) {\n    store.doDesktopAddConsent(consent)\n  }\n}\n\n/**\n * @param {string|string[]} consent\n * @param {Store} store\n */\nfunction removeConsent (consent, store) {\n  root.Countly.q.push(['remove_consent', consent])\n\n  if (store.selectIsIpfsDesktop()) {\n    store.doDesktopRemoveConsent(consent)\n  }\n}\n\n/**\n * @typedef {import('redux-bundler').Selectors<typeof selectors>} Selectors\n */\n\nconst selectors = {\n  /**\n   * @param {State} state\n   */\n  selectAnalytics: (state) => state.analytics,\n  /**\n   * @param {State} state\n   */\n  selectAnalyticsConsent: (state) => state.analytics.consent,\n  /**\n   * @param {State} state\n   */\n  selectAnalyticsEnabled: (state) => state.analytics.consent.length > 0,\n  /**\n   * Ask the user if we may enable analytics.\n   * @param {State} state\n   */\n  selectAnalyticsAskToEnable: (state) => {\n    const { lastEnabledAt, lastDisabledAt, consent } = state.analytics\n    // user has not explicitly chosen\n    if (!lastEnabledAt && !lastDisabledAt && consent.length === 0) {\n      // ask to enable.\n      return true\n    }\n    // user has already made an explicit choice; dont ask again.\n    return false\n  },\n\n  selectAnalyticsActionsToRecord: createSelector(\n    'selectIsIpfsDesktop',\n    'selectDesktopCountlyActions',\n    /**\n     * @param {boolean} isDesktop\n     * @param {string[]} desktopActions\n     * @returns {string[]}\n     */\n    (isDesktop, desktopActions) => {\n      return isDesktop\n        ? desktopActions.concat(ASYNC_ACTIONS_TO_RECORD).sort()\n        : Array.from(ASYNC_ACTIONS_TO_RECORD).sort()\n    }\n  )\n}\n\n/**\n * @typedef {import('./ipfs-desktop').Ext} DesktopExt\n * @typedef {import('redux-bundler').Actions<typeof actions>} Actions\n * @typedef {Selectors & Actions & DesktopExt} Ext\n * @typedef {import('redux-bundler').Store<State, Message, Ext>} Store\n * @typedef {import('redux-bundler').Context<State, Message, Ext>} Context\n */\n\nconst actions = {\n  /**\n   * @returns {function(Context):void}\n   */\n  doToggleAnalytics: () => ({ store }) => {\n    const enable = !store.selectAnalyticsEnabled()\n    if (enable) {\n      store.doEnableAnalytics()\n    } else {\n      store.doDisableAnalytics()\n    }\n  },\n  /**\n   * @returns {function(Context):void}\n   */\n  doDisableAnalytics: () => ({ dispatch, store }) => {\n    root.Countly.opt_out()\n    removeConsent(consentGroups.all, store)\n    dispatch({ type: 'ANALYTICS_DISABLED', payload: { consent: [] } })\n  },\n  /**\n   * @returns {function(Context):void}\n   */\n  doEnableAnalytics: () => ({ dispatch, store }) => {\n    removeConsent(consentGroups.all, store)\n    root.Countly.opt_in()\n    addConsent(consentGroups.safe, store)\n    dispatch({ type: 'ANALYTICS_ENABLED', payload: { consent: consentGroups.safe } })\n  },\n  /**\n   * @param {string} name\n   * @returns {function(Context):void}\n   */\n  doToggleConsent: (name) => ({ store }) => {\n    const isEnabled = store.selectAnalyticsConsent().includes(name)\n    if (isEnabled) {\n      store.doRemoveConsent(name)\n    } else {\n      store.doAddConsent(name)\n    }\n  },\n  /**\n   * @param {string} name\n   * @returns {function(Context):void}\n   */\n  doRemoveConsent: (name) => ({ dispatch, store }) => {\n    const existingConsents = store.selectAnalyticsConsent()\n    const remainingConsents = existingConsents.filter(item => item !== name)\n    // Ensure the users is fully opted out of analytics if they remove all consents.\n    // This means the consent removal event is not sent to countly, which is good.\n    // If a user tells us to send nothing, we send nothing.\n    // see: https://github.com/ipfs/ipfs-webui/issues/1041\n    if (remainingConsents.length === 0) {\n      root.Countly.opt_out()\n    }\n    removeConsent(name, store)\n    dispatch({ type: 'ANALYTICS_REMOVE_CONSENT', payload: { name } })\n  },\n  /**\n   * @param {string} name\n   * @returns {function(Context):void}\n   */\n  doAddConsent: (name) => ({ dispatch, store }) => {\n    const existingConsents = store.selectAnalyticsConsent()\n    if (existingConsents.length === 0) {\n      // Going from 0 to 1 consents opts you in to analytics\n      root.Countly.opt_in()\n    }\n    addConsent(name, store)\n    dispatch({ type: 'ANALYTICS_ADD_CONSENT', payload: { name } })\n  }\n}\n\nconst createAnalyticsBundle = ({\n  countlyUrl = 'https://countly.ipfs.io',\n  countlyAppKey = pickAppKey(),\n  appVersion = process.env.REACT_APP_VERSION,\n  // @ts-ignore - declared but never used\n  appGitRevision = process.env.REACT_APP_GIT_REV,\n  debug = false\n}) => {\n  return {\n    name: 'analytics',\n\n    persistActions: [\n      ACTIONS.ANALYTICS_ENABLED,\n      ACTIONS.ANALYTICS_DISABLED,\n      ACTIONS.ANALYTICS_DISABLED,\n      ACTIONS.ANALYTICS_ADD_CONSENT,\n      ACTIONS.ANALYTICS_REMOVE_CONSENT\n    ],\n\n    /**\n     * @param {Store} store\n     */\n    init: async (store) => {\n      // test code sets a mock Counly instance on the global.\n      if (!root.Countly) {\n        root.Countly = {}\n        root.Countly.q = []\n        // @ts-ignore\n        await import('countly-sdk-web')\n      }\n      const Countly = root.Countly\n\n      Countly.require_consent = true\n      Countly.url = countlyUrl\n      Countly.app_key = countlyAppKey\n      Countly.app_version = appVersion\n      Countly.debug = debug\n\n      if (store.selectIsIpfsDesktop()) {\n        Countly.app_version = store.selectDesktopVersion()\n        Countly.q.push(['change_id', store.selectDesktopCountlyDeviceId(), true])\n      }\n\n      // Configure what to track. Nothing is sent without user consent.\n      Countly.q.push(['track_sessions'])\n      Countly.q.push(['track_errors'])\n\n      // Don't track clicks or links as it can include full url.\n      // Countly.q.push(['track_clicks'])\n      // Countly.q.push(['track_links'])\n\n      if (store.selectAnalyticsEnabled()) {\n        const consent = store.selectAnalyticsConsent()\n        addConsent(consent, store)\n      }\n\n      store.subscribeToSelectors(['selectRouteInfo'], ({ routeInfo }) => {\n        // skip routes with no hash, as we'll be immediately redirected to `/#`\n        if (!root.location || !root.location.hash) return\n        /*\n        By tracking the pattern rather than the window.location, we limit the info\n        we collect to just the app sections that are viewed, and avoid recording\n        specific CIDs or local repo paths that would contain personal information.\n        */\n        root.Countly.q.push(['track_pageview', routeInfo.pattern])\n      })\n\n      // Fix for storybook error 'Countly.init is not a function'\n      if (typeof Countly.init === 'function') {\n        Countly.init()\n      }\n    },\n\n    // Listen to redux actions\n    getMiddleware: () => () => {\n      /**\n       * @param {function(Message):void} next\n       * @returns {function(Message):void}\n       */\n      const middleware = next => action => {\n        const payload = parseTask(action)\n        if (payload) {\n          const { id, duration, error } = payload\n          root.Countly.q.push(['add_event', {\n            key: id,\n            count: 1,\n            dur: duration\n          }])\n\n          // Record errors. Only from explicitly selected actions.\n          if (error) {\n            root.Countly.q.push(['add_log', action.type])\n            root.Countly.q.push(['log_error', error])\n          }\n        }\n\n        return next(action)\n      }\n\n      return middleware\n    },\n\n    /**\n     * @param {Model|void} state\n     * @param {Message} action\n     * @returns {Model}\n     */\n    reducer: (state, action) => {\n      state = state || {\n        lastEnabledAt: 0,\n        lastDisabledAt: 0,\n        consent: []\n      }\n\n      switch (action.type) {\n        case ACTIONS.ANALYTICS_ENABLED:\n          return { ...state, lastEnabledAt: Date.now(), consent: action.payload.consent }\n        case ACTIONS.ANALYTICS_DISABLED:\n          return { ...state, lastDisabledAt: Date.now(), consent: action.payload.consent }\n        case ACTIONS.ANALYTICS_ADD_CONSENT: {\n          const consent = state.consent.filter(item => item !== action.payload.name).concat(action.payload.name)\n          return { ...state, lastEnabledAt: Date.now(), consent }\n        }\n        case ACTIONS.ANALYTICS_REMOVE_CONSENT: {\n          const consent = state.consent.filter(item => item !== action.payload.name)\n          const lastDisabledAt = (consent.length === 0) ? Date.now() : state.lastDisabledAt\n          return { ...state, lastDisabledAt, consent }\n        }\n        default: {\n          // deal with missing consent state from 2.4.0 release.\n          if (!state.consent) {\n            if (state.lastEnabledAt > state.lastDisabledAt) {\n              return { ...state, consent: consentGroups.safe }\n            } else {\n              return { ...state, consent: [] }\n            }\n          }\n\n          return state\n        }\n      }\n    },\n\n    ...selectors,\n\n    ...actions\n  }\n}\n\n/**\n * @param {Message} action\n */\nconst parseTask = (action) => {\n  switch (action.type) {\n    case FILES.MAKE_DIR:\n    case FILES.WRITE:\n    case FILES.ADD_BY_PATH:\n    case FILES.MOVE:\n    case FILES.DELETE:\n    case FILES.DOWNLOAD_LINK:\n    case INIT.IPFS_INIT:\n    case CONIFG.CONFIG_SAVE:\n      return parseTaskResult(action.task, action.type)\n    case EXP.EXPERIMENTS_TOGGLE:\n      return parseToggleResult(action.task, 'EXPERIMENTS')\n    case DESKTOP.DESKTOP_SETTING_TOGGLE:\n      return parseToggleResult(action.task, 'DESKTOP_SETTING')\n    default:\n      return null\n  }\n}\n\n/**\n * @param {Init['task']|ConfigSave['task']|FilesMessage['task']} task\n * @param {string} name\n */\nconst parseTaskResult = (task, name) => {\n  if (task.status === 'Exit') {\n    const { duration, result } = task\n    const id = result.ok ? name : `${name}_FAILED`\n    const error = result.ok ? null : result.error\n    return { id, duration, error }\n  } else {\n    return null\n  }\n}\n\n/**\n * @param {Toggle['task']} task\n * @param {string} name\n */\nconst parseToggleResult = (task, name) => {\n  if (task.status === 'Exit') {\n    const { result, duration } = task\n    const { key } = result.ok ? result.value : result.error\n    const error = result.ok ? null : result.error\n    const status = !result.ok\n      ? 'FAILED'\n      : result.value.value\n        ? 'ENABLED'\n        : 'DISABLED'\n\n    const id = `${name}_${changeCase.constantCase(key)}_${status}`\n\n    return { id, duration, error }\n  }\n  return null\n}\n\nexport default createAnalyticsBundle\n","import { createAsyncResourceBundle, createSelector } from 'redux-bundler'\n\nconst bundle = createAsyncResourceBundle({\n  name: 'cliTutorMode',\n  actionBaseType: 'CLI_TUTOR_MODE_TOGGLE',\n  persist: true,\n  checkIfOnline: false,\n  getPromise: () => {}\n})\n\nbundle.reactIsCliTutorModeEnabled = createSelector(\n  'selectIsCliTutorModeEnabled',\n  (isCliTutorModeEnabled) => {\n    const isEnabled = Boolean(JSON.parse(localStorage.getItem('isCliTutorModeEnabled')))\n\n    if (isCliTutorModeEnabled !== undefined && isCliTutorModeEnabled !== isEnabled) {\n      localStorage.setItem('isCliTutorModeEnabled', isCliTutorModeEnabled)\n    }\n  }\n)\n\nbundle.selectIsCliTutorModeEnabled = state => state.cliTutorMode.isCliTutorModeEnabled\n\nbundle.selectIsCliTutorModalOpen = state => !!state.cliTutorMode.showCliTutorModal\n\nbundle.selectCliOptions = state => state.cliTutorMode.cliOptions\n\nbundle.reducer = (state = {}, action) => {\n  if (action.type === 'CLI_TUTOR_MODE_TOGGLE') {\n    return { ...state, isCliTutorModeEnabled: action.payload }\n  }\n  if (action.type === 'CLI_TUTOR_MODAL_ENABLE') {\n    return { ...state, showCliTutorModal: action.payload }\n  }\n  if (action.type === 'CLI_OPTIONS') {\n    return { ...state, cliOptions: action.payload }\n  }\n\n  return state\n}\n\nbundle.doToggleCliTutorMode = key => ({ dispatch }) => {\n  dispatch({\n    type: 'CLI_TUTOR_MODE_TOGGLE',\n    payload: key\n  })\n}\n\nbundle.doSetCliOptions = cliOptions => ({ dispatch }) => {\n  dispatch({\n    type: 'CLI_OPTIONS',\n    payload: cliOptions\n  })\n}\n\nbundle.doOpenCliTutorModal = openModal => ({ dispatch }) => {\n  dispatch({\n    type: 'CLI_TUTOR_MODAL_ENABLE',\n    payload: openModal\n  })\n}\n\nbundle.doOpenCliTutorModal = openModal => ({ dispatch }) => {\n  dispatch({\n    type: 'CLI_TUTOR_MODAL_ENABLE',\n    payload: openModal\n  })\n}\n\nbundle.init = store => {\n  const isEnabled = Boolean(JSON.parse(localStorage.getItem('isCliTutorModeEnabled')))\n  return store.doToggleCliTutorMode(isEnabled)\n}\nexport default bundle\n","import all from 'it-all'\nimport { readSetting, writeSetting } from './local-storage'\n\nconst init = () => ({\n  keys: [],\n  expectedPublishTime: readSetting('expectedPublishTime') || 60\n})\n\nconst ipnsBundle = {\n  name: 'ipns',\n  reducer: (state = init(), action) => {\n    if (action.type === 'CACHE_IPNS_KEYS') {\n      return { ...state, keys: action.payload }\n    }\n\n    if (action.type === 'SET_EXPECTED_PUBLISH_TIME') {\n      return { ...state, expectedPublishTime: action.payload }\n    }\n\n    return state\n  },\n\n  selectIpnsKeys: (state) => state.ipns.keys || [],\n\n  selectExpectedPublishTime: (state) => state.ipns.expectedPublishTime,\n\n  doFetchIpnsKeys: () => async ({ getIpfs, dispatch }) => {\n    const ipfs = getIpfs()\n    const rawKeys = await ipfs.key.list()\n    const keys = []\n\n    for (const { id, name } of rawKeys) {\n      const names = await all(ipfs.name.resolve(`/ipns/${id}`, { offline: true }))\n      const published = names.length > 0\n      keys.push({ id, name, published })\n    }\n\n    dispatch({ type: 'CACHE_IPNS_KEYS', payload: keys })\n  },\n\n  doGenerateIpnsKey: (name) => async ({ getIpfs, store }) => {\n    const ipfs = getIpfs()\n    await ipfs.key.gen(name)\n    store.doFetchIpnsKeys()\n  },\n\n  doRemoveIpnsKey: (name) => async ({ getIpfs, store }) => {\n    const ipfs = getIpfs()\n    await ipfs.key.rm(name)\n\n    store.doFetchIpnsKeys()\n  },\n\n  doRenameIpnsKey: (oldName, newName) => async ({ getIpfs, store }) => {\n    const ipfs = getIpfs()\n    await ipfs.key.rename(oldName, newName)\n\n    store.doFetchIpnsKeys()\n  },\n\n  doPublishIpnsKey: (cid, key) => async ({ getIpfs, store }) => {\n    const ipfs = getIpfs()\n    await ipfs.name.publish(cid, { key })\n  },\n\n  doUpdateExpectedPublishTime: (time) => async ({ store, dispatch }) => {\n    // moderate expectation: publishing should take no longer than average\n    // between old expectation and the length of the last publish + some buffer\n    const oldExpectedTime = store.selectExpectedPublishTime()\n    const avg = Math.floor((time * 1.5 + oldExpectedTime) / 2)\n    await writeSetting('expectedPublishTime', avg)\n    dispatch({ type: 'SET_EXPECTED_PUBLISH_TIME', payload: avg })\n  }\n}\n\nexport default ipnsBundle\n","import { composeBundles, createCacheBundle } from 'redux-bundler'\nimport ipfsProvider from './ipfs-provider'\nimport { exploreBundle } from 'ipld-explorer-components'\nimport appIdle from './app-idle'\nimport nodeBandwidthChartBundle from './node-bandwidth-chart'\nimport nodeBandwidthBundle from './node-bandwidth'\nimport peersBundle from './peers'\nimport peerLocationsBundle from './peer-locations'\nimport pinningBundle from './pinning'\nimport routesBundle from './routes'\nimport redirectsBundle from './redirects'\nimport filesBundle from './files'\nimport configBundle from './config'\nimport configSaveBundle from './config-save'\nimport toursBundle from './tours'\nimport notifyBundle from './notify'\nimport connectedBundle from './connected'\nimport retryInitBundle from './retry-init'\nimport identityBundle from './identity'\nimport bundleCache from '../lib/bundle-cache'\nimport ipfsDesktop from './ipfs-desktop'\nimport repoStats from './repo-stats'\nimport createAnalyticsBundle from './analytics'\nimport experimentsBundle from './experiments'\nimport cliTutorModeBundle from './cli-tutor-mode'\nimport gatewayBundle from './gateway'\nimport ipnsBundle from './ipns'\n\nexport default composeBundles(\n  createCacheBundle({\n    cacheFn: bundleCache.set\n  }),\n  appIdle({ idleTimeout: 5000 }),\n  ipfsProvider,\n  identityBundle,\n  routesBundle,\n  redirectsBundle,\n  toursBundle,\n  filesBundle(),\n  exploreBundle(),\n  configBundle,\n  configSaveBundle,\n  gatewayBundle,\n  nodeBandwidthBundle,\n  nodeBandwidthChartBundle(),\n  peersBundle,\n  peerLocationsBundle(),\n  pinningBundle,\n  notifyBundle,\n  connectedBundle,\n  retryInitBundle,\n  experimentsBundle,\n  ipfsDesktop,\n  repoStats,\n  cliTutorModeBundle,\n  createAnalyticsBundle({}),\n  ipnsBundle\n)\n","import { createElement, useMemo } from 'react';\nimport { I18nContext } from './context';\nexport function I18nextProvider(_ref) {\n  var i18n = _ref.i18n,\n      defaultNS = _ref.defaultNS,\n      children = _ref.children;\n  var value = useMemo(function () {\n    return {\n      i18n: i18n,\n      defaultNS: defaultNS\n    };\n  }, [i18n, defaultNS]);\n  return createElement(I18nContext.Provider, {\n    value: value\n  }, children);\n}","function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport * as React from 'react';\nimport { memo } from 'react';\nimport { DndContext, createDndContext } from './DndContext';\nvar refCount = 0;\n/**\n * A React component that provides the React-DnD context\n */\n\nexport var DndProvider = memo(function (_ref) {\n  var children = _ref.children,\n      props = _objectWithoutProperties(_ref, [\"children\"]);\n\n  var _getDndContextValue = getDndContextValue(props),\n      _getDndContextValue2 = _slicedToArray(_getDndContextValue, 2),\n      manager = _getDndContextValue2[0],\n      isGlobalInstance = _getDndContextValue2[1]; // memoized from props\n\n  /**\n   * If the global context was used to store the DND context\n   * then where theres no more references to it we should\n   * clean it up to avoid memory leaks\n   */\n\n\n  React.useEffect(function () {\n    if (isGlobalInstance) {\n      refCount++;\n    }\n\n    return function () {\n      if (isGlobalInstance) {\n        refCount--;\n\n        if (refCount === 0) {\n          var context = getGlobalContext();\n          context[instanceSymbol] = null;\n        }\n      }\n    };\n  }, []);\n  return React.createElement(DndContext.Provider, {\n    value: manager\n  }, children);\n});\nDndProvider.displayName = 'DndProvider';\n\nfunction getDndContextValue(props) {\n  if ('manager' in props) {\n    var _manager = {\n      dragDropManager: props.manager\n    };\n    return [_manager, false];\n  }\n\n  var manager = createSingletonDndContext(props.backend, props.context, props.options, props.debugMode);\n  var isGlobalInstance = !props.context;\n  return [manager, isGlobalInstance];\n}\n\nvar instanceSymbol = Symbol.for('__REACT_DND_CONTEXT_INSTANCE__');\n\nfunction createSingletonDndContext(backend) {\n  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getGlobalContext();\n  var options = arguments.length > 2 ? arguments[2] : undefined;\n  var debugMode = arguments.length > 3 ? arguments[3] : undefined;\n  var ctx = context;\n\n  if (!ctx[instanceSymbol]) {\n    ctx[instanceSymbol] = createDndContext(backend, context, options, debugMode);\n  }\n\n  return ctx[instanceSymbol];\n}\n\nfunction getGlobalContext() {\n  return typeof global !== 'undefined' ? global : window;\n}","// cheap lodash replacements\nexport function memoize(fn) {\n  var result = null;\n\n  var memoized = function memoized() {\n    if (result == null) {\n      result = fn();\n    }\n\n    return result;\n  };\n\n  return memoized;\n}\n/**\n * drop-in replacement for _.without\n */\n\nexport function without(items, item) {\n  return items.filter(function (i) {\n    return i !== item;\n  });\n}\nexport function union(itemsA, itemsB) {\n  var set = new Set();\n\n  var insertItem = function insertItem(item) {\n    return set.add(item);\n  };\n\n  itemsA.forEach(insertItem);\n  itemsB.forEach(insertItem);\n  var result = [];\n  set.forEach(function (key) {\n    return result.push(key);\n  });\n  return result;\n}","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { union, without } from './utils/js_utils';\nexport var EnterLeaveCounter = /*#__PURE__*/function () {\n  function EnterLeaveCounter(isNodeInDocument) {\n    _classCallCheck(this, EnterLeaveCounter);\n\n    this.entered = [];\n    this.isNodeInDocument = isNodeInDocument;\n  }\n\n  _createClass(EnterLeaveCounter, [{\n    key: \"enter\",\n    value: function enter(enteringNode) {\n      var _this = this;\n\n      var previousLength = this.entered.length;\n\n      var isNodeEntered = function isNodeEntered(node) {\n        return _this.isNodeInDocument(node) && (!node.contains || node.contains(enteringNode));\n      };\n\n      this.entered = union(this.entered.filter(isNodeEntered), [enteringNode]);\n      return previousLength === 0 && this.entered.length > 0;\n    }\n  }, {\n    key: \"leave\",\n    value: function leave(leavingNode) {\n      var previousLength = this.entered.length;\n      this.entered = without(this.entered.filter(this.isNodeInDocument), leavingNode);\n      return previousLength > 0 && this.entered.length === 0;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.entered = [];\n    }\n  }]);\n\n  return EnterLeaveCounter;\n}();","import { memoize } from './utils/js_utils';\nexport var isFirefox = memoize(function () {\n  return /firefox/i.test(navigator.userAgent);\n});\nexport var isSafari = memoize(function () {\n  return Boolean(window.safari);\n});","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.le